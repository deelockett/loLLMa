-- Moses @6fe8d76d50a22d85fe064aaa80390b72381befed | /moses.lua | https://github.com/Yonaba/Moses | License: MIT License | Minified using https://www.npmjs.com/package/luamin/v/1.0.4
-- Copyright (c) 2012-2018 Roland Yonaba
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
-- The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
local a='2.1.0'local next,type,pcall=next,type,pcall;local setmetatable,getmetatable=setmetatable,getmetatable;local b,c=table.insert,table.sort;local d,e=table.remove,table.concat;local f,g,h=math.randomseed,math.random,math.huge;local i,j,k,l=math.floor,math.max,math.min,math.ceil;local m=coroutine.wrap;local n=coroutine.yield;local rawget=rawget;local unpack=table.unpack or unpack;local pairs,ipairs=pairs,ipairs;local error=error;local o=os and os.clock or nil;local p={}local function q(r,s)return r>s end;local function t(r,s)return r<s end;local function u(v)local w=0;for x,y in pairs(v)do w=w+1 end;return w end;local function z(A,B,C,...)C=C or p.identity;local D;for x,y in pairs(A)do if not D then D=C(y,...)else local E=C(y,...)D=B(D,E)and D or E end end;return D end;local function F(v,G,H,I)for w=0,#v,G do local J=p.slice(v,w+1,w+G)if#J>0 then while#J<G and I do J[#J+1]=I end;H(J)end end end;local function K(v,G,H,I)for w=0,#v,G-1 do local J=p.slice(v,w+1,w+G)if#J>0 and w+1<#v then while#J<G and I do J[#J+1]=I end;H(J)end end end;local function L(v,G,H,I)for w=0,#v,1 do local J=p.slice(v,w+1,w+G)if#J>0 and w+G<=#v then while#J<G and I do J[#J+1]=I end;H(J)end end end;local function M(v,G,H)if G==0 then H(v)end;for w=1,G do v[G],v[w]=v[w],v[G]M(v,G-1,H)v[G],v[w]=v[w],v[G]end end;local function N(r)return r>=0 and 1 or-1 end;local O=-1;p.operator={}p.operator.add=function(r,s)return r+s end;p.operator.sub=function(r,s)return r-s end;p.operator.mul=function(r,s)return r*s end;p.operator.div=function(r,s)return r/s end;p.operator.mod=function(r,s)return r%s end;p.operator.exp=function(r,s)return r^s end;p.operator.pow=p.operator.exp;p.operator.unm=function(r)return-r end;p.operator.neg=p.operator.unm;p.operator.floordiv=function(r,s)return i(r/s)end;p.operator.intdiv=function(r,s)return r>=0 and i(r/s)or l(r/s)end;p.operator.eq=function(r,s)return r==s end;p.operator.neq=function(r,s)return r~=s end;p.operator.lt=function(r,s)return r<s end;p.operator.gt=function(r,s)return r>s end;p.operator.le=function(r,s)return r<=s end;p.operator.ge=function(r,s)return r>=s end;p.operator.land=function(r,s)return r and s end;p.operator.lor=function(r,s)return r or s end;p.operator.lnot=function(r)return not r end;p.operator.concat=function(r,s)return r..s end;p.operator.length=function(r)return#r end;p.operator.len=p.operator.length;function p.clear(v)for x in pairs(v)do v[x]=nil end;return v end;function p.each(v,H)for P,Q in pairs(v)do H(Q,P)end end;function p.eachi(v,H)local R=p.sort(p.select(p.keys(v),p.isInteger))for x,S in ipairs(R)do H(v[S],S)end end;function p.at(v,...)local T={}for w,S in ipairs({...})do T[#T+1]=v[S]end;return T end;function p.adjust(v,S,H)if v[S]==nil then error("key not existing in table")end;local U=p.clone(v)U[S]=type(H)=='function'and H(U[S])or H;return U end;function p.count(v,E)if E==nil then return p.size(v)end;local u=0;for x,y in pairs(v)do if p.isEqual(y,E)then u=u+1 end end;return u end;function p.countf(v,H)local u=0;for x,y in pairs(v)do if H(y,x)then u=u+1 end end;return u end;function p.allEqual(v,B)local x,V=next(v)for x,y in pairs(v)do if B then if not B(V,y)then return false end else if not p.isEqual(V,y)then return false end end end;return true end;function p.cycle(v,G)G=G or 1;if G<=0 then return p.noop end;local x,W;local w=0;while true do return function()x=x and next(v,x)or next(v)W=not W and x or W;if G then w=x==W and w+1 or w;if w>G then return end end;return v[x],x end end end;function p.map(v,H)local U={}for P,Q in pairs(v)do local x,X,y=P,H(Q,P)U[y and X or x]=y or X end;return U end;function p.mapi(v,H)local U={}for P,Q in ipairs(v)do local x,X,y=P,H(Q,P)U[y and X or x]=y or X end;return U end;function p.reduce(v,H,Y)for x,Q in pairs(v)do if Y==nil then Y=Q else Y=H(Y,Q)end end;return Y end;function p.best(v,H)local Z,Y=next(v)for x,Q in pairs(v)do if Y==nil then Y=Q else Y=H(Y,Q)and Y or Q end end;return Y end;function p.reduceBy(v,H,_,Y)return p.reduce(p.select(v,_),H,Y)end;function p.reduceRight(v,H,Y)return p.reduce(p.reverse(v),H,Y)end;function p.mapReduce(v,H,Y)local U={}for w,Q in pairs(v)do U[w]=not Y and Q or H(Y,Q)Y=U[w]end;return U end;function p.mapReduceRight(v,H,Y)return p.mapReduce(p.reverse(v),H,Y)end;function p.include(v,Q)local a0=type(Q)=='function'and Q or p.isEqual;for x,y in pairs(v)do if a0(y,Q)then return true end end;return false end;function p.detect(v,Q)local a0=type(Q)=='function'and Q or p.isEqual;for S,a1 in pairs(v)do if a0(a1,Q)then return S end end end;function p.where(v,a2)local a3=p.select(v,function(y)for S in pairs(a2)do if y[S]~=a2[S]then return false end end;return true end)return#a3>0 and a3 or nil end;function p.findWhere(v,a2)local P=p.detect(v,function(y)for S in pairs(a2)do if a2[S]~=y[S]then return false end end;return true end)return P and v[P]end;function p.select(v,H)local U={}for P,Q in pairs(v)do if H(Q,P)then U[#U+1]=Q end end;return U end;function p.reject(v,H)local U={}for P,Q in pairs(v)do if not H(Q,P)then U[#U+1]=Q end end;return U end;function p.all(v,H)for P,Q in pairs(v)do if not H(Q,P)then return false end end;return true end;function p.invoke(v,a4)return p.map(v,function(y,x)if type(y)=='table'then if y[a4]then if p.isCallable(y[a4])then return y[a4](y,x)else return y[a4]end else if p.isCallable(a4)then return a4(y,x)end end elseif p.isCallable(a4)then return a4(y,x)end end)end;function p.pluck(v,S)local U={}for x,y in pairs(v)do if y[S]then U[#U+1]=y[S]end end;return U end;function p.max(v,C)return z(v,q,C)end;function p.min(v,C)return z(v,t,C)end;function p.same(r,s)return p.all(r,function(y)return p.include(s,y)end)and p.all(s,function(y)return p.include(r,y)end)end;function p.sort(v,B)c(v,B)return v end;function p.sortedk(v,B)local a5=p.keys(v)c(a5,B)local w=0;return function()w=w+1;return a5[w],v[a5[w]]end end;function p.sortedv(v,B)local a5=p.keys(v)B=B or t;c(a5,function(r,s)return B(v[r],v[s])end)local w=0;return function()w=w+1;return a5[w],v[a5[w]]end end;function p.sortBy(v,C,B)local H=C or p.identity;if type(C)=='string'then H=function(v)return v[C]end end;B=B or t;c(v,function(r,s)return B(H(r),H(s))end)return v end;function p.groupBy(v,a6)local U={}for x,y in pairs(v)do local a7=a6(y,x)if U[a7]then U[a7][#U[a7]+1]=y else U[a7]={y}end end;return U end;function p.countBy(v,a6)local a8={}for w,y in pairs(v)do local S=a6(y,w)a8[S]=(a8[S]or 0)+1 end;return a8 end;function p.size(...)local a9={...}local aa=a9[1]return type(aa)=='table'and u(a9[1])or u(a9)end;function p.containsKeys(v,ab)for S in pairs(ab)do if not v[S]then return false end end;return true end;function p.sameKeys(ac,ad)for S in pairs(ac)do if not ad[S]then return false end end;for S in pairs(ad)do if not ac[S]then return false end end;return true end;function p.sample(ae,G,af)G=G or 1;if G==0 then return{}end;if G==1 then if af then f(af)end;return{ae[g(1,#ae)]}end;return p.slice(p.shuffle(ae,af),1,G)end;function p.sampleProb(ae,ag,af)if af then f(af)end;local v={}for x,y in ipairs(ae)do if g()<ag then v[#v+1]=y end end;return v end;function p.nsorted(ae,G,B)B=B or t;G=G or 1;local T,u={},0;for x,y in p.sortedv(ae,B)do if u<G then u=u+1;T[u]=y end end;return T end;function p.shuffle(ae,af)if af then f(af)end;local ah={}for P,Q in ipairs(ae)do local ai=i(g()*P)+1;ah[P]=ah[ai]ah[ai]=Q end;return ah end;function p.pack(...)return{...}end;function p.find(ae,Q,aj)for w=aj or 1,#ae do if p.isEqual(ae[w],Q)then return w end end end;function p.reverse(ae)local ak={}for w=#ae,1,-1 do ak[#ak+1]=ae[w]end;return ak end;function p.fill(ae,Q,w,al)al=al or p.size(ae)for w=w or 1,al do ae[w]=Q end;return ae end;function p.zeros(G)return p.fill({},0,1,G)end;function p.ones(G)return p.fill({},1,1,G)end;function p.vector(Q,G)return p.fill({},Q,1,G)end;function p.selectWhile(ae,H)local v={}for w,y in ipairs(ae)do if H(y,w)then v[w]=y else break end end;return v end;function p.dropWhile(ae,H)local am;for w,y in ipairs(ae)do if not H(y,w)then am=w;break end end;if am==nil then return{}end;return p.rest(ae,am)end;function p.sortedIndex(ae,Q,B,an)local ao=B or t;if an==true then c(ae,ao)end;for w=1,#ae do if not ao(ae[w],Q)then return w end end;return#ae+1 end;function p.indexOf(ae,Q)for x=1,#ae do if ae[x]==Q then return x end end end;function p.lastIndexOf(ae,Q)local S=p.indexOf(p.reverse(ae),Q)if S then return#ae-S+1 end end;function p.findIndex(ae,_)for x=1,#ae do if _(ae[x],x)then return x end end end;function p.findLastIndex(ae,_)local S=p.findIndex(p.reverse(ae),_)if S then return#ae-S+1 end end;function p.addTop(ae,...)for x,y in ipairs({...})do b(ae,1,y)end;return ae end;function p.prepend(ae,...)return p.append({...},ae)end;function p.push(ae,...)local a9={...}for x,y in ipairs({...})do ae[#ae+1]=y end;return ae end;function p.shift(ae,G)G=k(G or 1,#ae)local ap={}for w=1,G do local aq=ae[1]ap[#ap+1]=aq;d(ae,1)end;return unpack(ap)end;function p.unshift(ae,G)G=k(G or 1,#ae)local ap={}for w=1,G do local aq=ae[#ae]ap[#ap+1]=aq;d(ae)end;return unpack(ap)end;function p.pull(ae,...)local T={...}for w=#ae,1,-1 do local ar=false;for x,as in ipairs(T)do if ar==false then if p.isEqual(ae[w],as)then d(ae,w)ar=true end end end end;return ae end;function p.removeRange(ae,at,au)at=at or 1;au=au or#ae;if at>au then error("start cannot be greater than finish.")end;for w=au,at,-1 do d(ae,w)end;return ae end;function p.chunk(ae,H)local av,aw,ax,E={},0;H=H or p.identity;for x,y in ipairs(ae)do E=H(y,x)aw=E~=ax and aw+1 or aw;ax=ax==nil and E or ax;if not av[aw]then av[aw]={ae[x]}else av[aw][#av[aw]+1]=ae[x]end;ax=E end;return av end;function p.slice(ae,at,au)local v={}for x=at or 1,au or#ae do v[#v+1]=ae[x]end;return v end;function p.first(ae,G)G=G or 1;local v={}for x=1,G do v[x]=ae[x]end;return v end;function p.initial(ae,G)local ay=#ae;G=G and ay-k(G,ay)or ay-1;local v={}for x=1,G do v[x]=ae[x]end;return v end;function p.last(ae,G)local ay=#ae;G=G and ay-k(G-1,ay-1)or 2;local v={}for x=G,ay do v[#v+1]=ae[x]end;return v end;function p.rest(ae,P)local v={}for x=P or 1,#ae do v[#v+1]=ae[x]end;return v end;function p.nth(ae,P)return ae[P]end;function p.compact(ae)local v={}for x,y in pairs(ae)do if y then v[#v+1]=y end end;return v end;function p.flatten(ae,az)az=az or false;local aA;local aB={}for S,Q in ipairs(ae)do if type(Q)=='table'then aA=az and Q or p.flatten(Q)for x,aC in ipairs(aA)do aB[#aB+1]=aC end else aB[#aB+1]=Q end end;return aB end;function p.difference(ae,aD)if not aD then return p.clone(ae)end;return p.select(ae,function(Q)return not p.include(aD,Q)end)end;function p.union(...)return p.unique(p.flatten({...}))end;function p.intersection(...)local a1={...}local ae=a1[1]d(a1,1)local aE={}for w,Q in ipairs(ae)do if p.all(a1,function(y)return p.include(y,Q)end)then aE[#aE+1]=Q end end;return aE end;function p.disjoint(...)return#p.intersection(...)==0 end;function p.symmetricDifference(ae,aD)return p.difference(p.union(ae,aD),p.intersection(ae,aD))end;function p.unique(ae)local ap={}for w=1,#ae do if not p.find(ap,ae[w])then ap[#ap+1]=ae[w]end end;return ap end;function p.isunique(ae)return#ae==#p.unique(ae)end;function p.duplicates(ae)local aF=p.invert(ae)local aG={}for x,y in ipairs(ae)do if aF[y]~=x and not p.find(aG,y)then aG[#aG+1]=y end end;return aG end;function p.zip(...)local a9={...}local G=p.max(a9,function(ae)return#ae end)local D={}for w=1,G do if not D[w]then D[w]={}end;for x,ae in ipairs(a9)do if ae[w]~=nil then D[w][#D[w]+1]=ae[w]end end end;return D end;function p.zipWith(H,...)local a9={...}local G=p.max(a9,function(ae)return#ae end)local D={}for w=1,G do D[w]=H(unpack(p.pluck(a9,w)))end;return D end;function p.append(ae,ab)local v={}for w,y in ipairs(ae)do v[w]=y end;for w,y in ipairs(ab)do v[#v+1]=y end;return v end;function p.interleave(...)local a9={...}local G=p.max(a9,p.size)local v={}for w=1,G do for x,ae in ipairs(a9)do if ae[w]then v[#v+1]=ae[w]end end end;return v end;function p.interpose(ae,Q)for x=#ae,2,-1 do b(ae,x,Q)end;return ae end;function p.range(aj,aH,aI)if aj==nil and aH==nil and aI==nil then return{}elseif aj~=nil and aH==nil and aI==nil then aj,aH,aI=N(aj),aj,N(aj)elseif aj~=nil and aH~=nil and aI==nil then aI=N(aH-aj)end;local aJ={aj}local aK=j(i((aH-aj)/aI),0)for w=1,aK do aJ[#aJ+1]=aj+aI*w end;return aJ end;function p.rep(Q,G)local ap={}for w=1,G do ap[w]=Q end;return ap end;function p.powerset(ae)local G=#ae;local aL={}for w,y in ipairs(ae)do for al=1,#aL do local aM=aL[al]b(aL,p.push(p.slice(aM),y))end;b(aL,{y})end;b(aL,{})return aL end;function p.partition(ae,G,I)if G<=0 then return end;return m(function()F(ae,G or 1,n,I)end)end;function p.overlapping(ae,G,I)if G<=1 then return end;return m(function()K(ae,G or 2,n,I)end)end;function p.aperture(ae,G)if G<=1 then return end;return m(function()L(ae,G or 2,n)end)end;function p.pairwise(ae)return p.aperture(ae,2)end;function p.permutation(ae)return m(function()M(ae,#ae,n)end)end;function p.concat(ae,aN,w,al)return e(p.map(ae,tostring),aN,w,al)end;function p.xprod(ae,aD)local aO={}for w,aP in ipairs(ae)do for al,aQ in ipairs(aD)do aO[#aO+1]={aP,aQ}end end;return aO end;function p.xpairs(Q,ae)local aR={}for x,y in ipairs(ae)do aR[x]={Q,y}end;return aR end;function p.xpairsRight(Q,ae)local aR={}for x,y in ipairs(ae)do aR[x]={y,Q}end;return aR end;function p.sum(ae)local J=0;for x,y in ipairs(ae)do J=J+y end;return J end;function p.product(ae)local aO=1;for x,y in ipairs(ae)do aO=aO*y end;return aO end;function p.mean(ae)return p.sum(ae)/#ae end;function p.median(ae)local v=p.sort(p.clone(ae))local G=#v;if G==0 then return elseif G==1 then return v[1]end;local aS=l(G/2)return G%2==0 and(v[aS]+v[aS+1])/2 or v[aS]end;function p.noop()return end;function p.identity(Q)return Q end;function p.call(H,...)return H(...)end;function p.constant(Q)return function()return Q end end;function p.applySpec(aT)return function(...)local aU={}for w,H in pairs(aT)do aU[w]=H(...)end;return aU end end;function p.thread(Q,...)local Y=Q;local a1={...}for x,v in ipairs(a1)do if type(v)=='function'then Y=v(Y)elseif type(v)=='table'then local H=v[1]d(v,1)Y=p.reduce(v,H,Y)end end;return Y end;function p.threadRight(Q,...)local Y=Q;local a1={...}for x,v in ipairs(a1)do if type(v)=='function'then Y=v(Y)elseif type(v)=='table'then local H=v[1]d(v,1)b(v,Y)Y=p.reduce(v,H)end end;return Y end;function p.dispatch(...)local aV={...}return function(...)for x,H in ipairs(aV)do local a3={H(...)}if#a3>0 then return unpack(a3)end end end end;function p.memoize(H)local aW=setmetatable({},{__mode='kv'})return function(S)if aW[S]==nil then aW[S]=H(S)end;return aW[S]end end;function p.unfold(H,af)local v,aX={}while true do aX,af=H(af)if aX~=nil then v[#v+1]=aX else break end end;return v end;function p.once(H)local aY=0;local aZ={}return function(...)aY=aY+1;if aY<=1 then aZ={...}end;return H(unpack(aZ))end end;function p.before(H,u)local aY=0;local aZ={}return function(...)aY=aY+1;if aY<=u then aZ={...}end;return H(unpack(aZ))end end;function p.after(H,u)local a_,aY=u,0;return function(...)aY=aY+1;if aY>=a_ then return H(...)end end end;function p.compose(...)local H=p.reverse{...}return function(...)local b0,b1=true;for w,b2 in ipairs(H)do if b0 then b0=false;b1=b2(...)else b1=b2(b1)end end;return b1 end end;function p.pipe(Q,...)return p.compose(...)(Q)end;function p.complement(H)return function(...)return not H(...)end end;function p.juxtapose(Q,...)local b3={}for w,b2 in ipairs({...})do b3[w]=b2(Q)end;return unpack(b3)end;function p.wrap(H,b4)return function(...)return b4(H,...)end end;function p.times(a6,G)local b5={}for w=1,G or 1 do b5[w]=a6(w)end;return b5 end;function p.bind(H,y)return function(...)return H(y,...)end end;function p.bind2(H,y)return function(v,...)return H(v,y,...)end end;function p.bindn(H,...)local a9={...}return function(...)return H(unpack(p.append(a9,{...})))end end;function p.bindall(b6,...)local b7={...}for w,b8 in ipairs(b7)do local a4=b6[b8]if a4 then b6[b8]=p.bind(a4,b6)end end;return b6 end;function p.cond(b9)return function(...)for x,ba in ipairs(b9)do if ba[1](...)then return ba[2](...)end end end end;function p.both(...)local aV={...}return function(...)for x,H in ipairs(aV)do if not H(...)then return false end end;return true end end;function p.either(...)local aV={...}return function(...)for x,H in ipairs(aV)do if H(...)then return true end end;return false end end;function p.neither(...)local aV={...}return function(...)for x,H in ipairs(aV)do if H(...)then return false end end;return true end end;function p.uniqueId(bb)O=O+1;if bb then if type(bb)=='string'then return bb:format(O)elseif type(bb)=='function'then return bb(O)end end;return O end;function p.iterator(H,Q,G)local bc=0;return function()bc=bc+1;if G and bc>G then return end;Q=H(Q)return Q end end;function p.skip(a6,G)for w=1,G or 1 do if a6()==nil then return end end;return a6 end;function p.tabulate(...)local a3={}for y in...do a3[#a3+1]=y end;return a3 end;function p.iterlen(...)local ay=0;for y in...do ay=ay+1 end;return ay end;function p.castArray(Q)return type(Q)~='table'and{Q}or Q end;function p.flip(H)return function(...)return H(unpack(p.reverse({...})))end end;function p.nthArg(G)return function(...)local a9={...}return a9[G<0 and#a9+G+1 or G]end end;function p.unary(H)return function(...)local a9={...}return H(a9[1])end end;function p.ary(H,G)G=G or 1;return function(...)local a9={...}local bd={}for w=1,G do bd[w]=a9[w]end;return H(unpack(bd))end end;function p.noarg(H)return function()return H()end end;function p.rearg(H,be)return function(...)local a9={...}local bf={}for w,a1 in ipairs(be)do bf[w]=a9[a1]end;return H(unpack(bf))end end;function p.over(...)local bg={...}return function(...)local a3={}for w,C in ipairs(bg)do a3[#a3+1]=C(...)end;return a3 end end;function p.overEvery(...)local H=p.over(...)return function(...)return p.reduce(H(...),function(Y,y)return Y and y end)end end;function p.overSome(...)local H=p.over(...)return function(...)return p.reduce(H(...),function(Y,y)return Y or y end)end end;function p.overArgs(H,...)local bh={...}return function(...)local aZ={...}for w=1,#bh do local b2=bh[w]if aZ[w]then aZ[w]=b2(aZ[w])end end;return H(unpack(aZ))end end;function p.converge(H,bi,bj)return function(...)return H(bi(...),bj(...))end end;function p.partial(H,...)local bk={...}return function(...)local bl={...}local bm={}for x,y in ipairs(bk)do bm[x]=y=='_'and p.shift(bl)or y end;return H(unpack(p.append(bm,bl)))end end;function p.partialRight(H,...)local bk={...}return function(...)local bl={...}local bm={}for x=1,#bk do bm[x]=bk[x]=='_'and p.shift(bl)or bk[x]end;return H(unpack(p.append(bl,bm)))end end;function p.curry(H,bl)bl=bl or 2;local aZ={}local function bn(y)if bl==1 then return H(y)end;if y~=nil then aZ[#aZ+1]=y end;if#aZ<bl then return bn else local a3={H(unpack(aZ))}aZ={}return unpack(a3)end end;return bn end;function p.time(H,...)local bo=o()local a3={H(...)}return o()-bo,unpack(a3)end;function p.keys(b6)local a5={}for S in pairs(b6)do a5[#a5+1]=S end;return a5 end;function p.values(b6)local T={}for S,Q in pairs(b6)do T[#T+1]=Q end;return T end;function p.path(b6,...)local Q,bp=b6,{...}for w,aO in ipairs(bp)do if Q[aO]==nil then return end;Q=Q[aO]end;return Q end;function p.spreadPath(b6,...)local bp={...}for Z,aO in ipairs(bp)do if b6[aO]then for x,y in pairs(b6[aO])do b6[x]=y;b6[aO][x]=nil end end end;return b6 end;function p.flattenPath(b6,...)local bp={...}for Z,aO in ipairs(bp)do if b6[aO]then for x,y in pairs(b6[aO])do b6[x]=y end end end;return b6 end;function p.kvpairs(b6)local v={}for x,y in pairs(b6)do v[#v+1]={x,y}end;return v end;function p.toObj(bq)local b6={}for x,y in ipairs(bq)do b6[y[1]]=y[2]end;return b6 end;function p.invert(b6)local br={}for x,y in pairs(b6)do br[y]=x end;return br end;function p.property(S)return function(b6)return b6[S]end end;function p.propertyOf(b6)return function(S)return b6[S]end end;function p.toBoolean(Q)return not not Q end;function p.extend(bs,...)local bt={...}for x,bu in ipairs(bt)do if type(bu)=='table'then for S,Q in pairs(bu)do bs[S]=Q end end end;return bs end;function p.functions(b6,bv)b6=b6 or p;local bw={}for S,Q in pairs(b6)do if type(Q)=='function'then bw[#bw+1]=S end end;if bv then local bx=getmetatable(b6)if bx and bx.__index then local by=p.functions(bx.__index,bv)for x,bz in ipairs(by)do bw[#bw+1]=bz end end end;return bw end;function p.clone(b6,az)if type(b6)~='table'then return b6 end;local bA={}for w,y in pairs(b6)do if type(y)=='table'then if not az then bA[w]=p.clone(y,az)else bA[w]=y end else bA[w]=y end end;return bA end;function p.tap(b6,H)H(b6)return b6 end;function p.has(b6,S)return b6[S]~=nil end;function p.pick(b6,...)local bB=p.flatten{...}local bC={}for S,bD in pairs(bB)do if b6[bD]~=nil then bC[bD]=b6[bD]end end;return bC end;function p.omit(b6,...)local bE=p.flatten{...}local bC={}for S,Q in pairs(b6)do if not p.include(bE,S)then bC[S]=Q end end;return bC end;function p.template(b6,bb)if not bb then return b6 end;for w,y in pairs(bb)do if not b6[w]then b6[w]=y end end;return b6 end;function p.isEqual(bF,bG,bH)local bI=type(bF)local bJ=type(bG)if bI~=bJ then return false end;if bI~='table'then return bF==bG end;local bK=getmetatable(bF)local bL=getmetatable(bG)if bH then if(bK or bL)and(bK.__eq or bL.__eq)then return bK.__eq(bF,bG)or bL.__eq(bG,bF)or bF==bG end end;if p.size(bF)~=p.size(bG)then return false end;local bM;for w,bN in pairs(bF)do bM=bG[w]if bM==nil or not p.isEqual(bN,bM,bH)then return false end end;for w in pairs(bG)do if bF[w]==nil then return false end end;return true end;function p.result(b6,a4)if b6[a4]then if p.isCallable(b6[a4])then return b6[a4](b6)else return b6[a4]end end;if p.isCallable(a4)then return a4(b6)end end;function p.isTable(v)return type(v)=='table'end;function p.isCallable(b6)return type(b6)=='function'or type(b6)=='table'and getmetatable(b6)and getmetatable(b6).__call~=nil or false end;function p.isArray(b6)if not(type(b6)=='table')then return false end;local w=0;for x in pairs(b6)do w=w+1;if b6[w]==nil then return false end end;return true end;function p.isIterable(b6)return p.toBoolean(pcall(pairs,b6))end;function p.type(b6)local bO=type(b6)if bO=='userdata'then local bx=getmetatable(b6)local bP=io and io.stdout or nil;if bP~=nil and bx==getmetatable(bP)then return'file'end end;return bO end;function p.isEmpty(b6)if b6==nil then return true end;if type(b6)=='string'then return#b6==0 end;if type(b6)=='table'then return next(b6)==nil end;return true end;function p.isString(b6)return type(b6)=='string'end;function p.isFunction(b6)return type(b6)=='function'end;function p.isNil(b6)return b6==nil end;function p.isNumber(b6)return type(b6)=='number'end;function p.isNaN(b6)return type(b6)=='number'and b6~=b6 end;function p.isFinite(b6)if type(b6)~='number'then return false end;return b6>-h and b6<h end;function p.isBoolean(b6)return type(b6)=='boolean'end;function p.isInteger(b6)return type(b6)=='number'and i(b6)==b6 end;do p.forEach=p.each;p.forEachi=p.eachi;p.update=p.adjust;p.alleq=p.allEqual;p.loop=p.cycle;p.collect=p.map;p.inject=p.reduce;p.foldl=p.reduce;p.injectr=p.reduceRight;p.foldr=p.reduceRight;p.mapr=p.mapReduce;p.maprr=p.mapReduceRight;p.any=p.include;p.some=p.include;p.contains=p.include;p.filter=p.select;p.discard=p.reject;p.every=p.all;p.takeWhile=p.selectWhile;p.rejectWhile=p.dropWhile;p.pop=p.shift;p.remove=p.pull;p.rmRange=p.removeRange;p.chop=p.removeRange;p.sub=p.slice;p.head=p.first;p.take=p.first;p.tail=p.rest;p.without=p.difference;p.diff=p.difference;p.symdiff=p.symmetricDifference;p.xor=p.symmetricDifference;p.uniq=p.unique;p.isuniq=p.isunique;p.transpose=p.zip;p.part=p.partition;p.perm=p.permutation;p.transposeWith=p.zipWith;p.intersperse=p.interpose;p.sliding=p.aperture;p.mirror=p.invert;p.join=p.concat;p.average=p.mean;p.always=p.constant;p.cache=p.memoize;p.juxt=p.juxtapose;p.uid=p.uniqueId;p.iter=p.iterator;p.nAry=p.ary;p.methods=p.functions;p.choose=p.pick;p.drop=p.omit;p.defaults=p.template;p.compare=p.isEqual;p.matches=p.isEqual end;do local H={}local bQ={}bQ.__index=H;local function bR(Q)return setmetatable({_value=Q,_wrapped=true},bQ)end;setmetatable(bQ,{__call=function(self,y)return bR(y)end,__index=function(v,S,...)return H[S]end})function bQ.chain(Q)return bR(Q)end;function bQ:value()return self._value end;H.chain,H.value=bQ.chain,bQ.value;for bS,bT in pairs(p)do if bS~='operator'then H[bS]=function(y,...)local bU=type(y)=='table'and rawget(y,'_wrapped')or false;if bU then local bV=y._value;local bW=bT(bV,...)return bR(bW)else return bT(y,...)end end end end;H.operator=p.operator;H.op=p.operator;H.import=function(bX,bY)bX=bX or _ENV or _G;local aV=p.functions()for x,bS in ipairs(aV)do if rawget(bX,bS)~=nil then if not bY then rawset(bX,bS,p[bS])end else rawset(bX,bS,p[bS])end end;return bX end;bQ._VERSION='Moses v'..a;bQ._URL='http://github.com/Yonaba/Moses'bQ._LICENSE='MIT <http://raw.githubusercontent.com/Yonaba/Moses/master/LICENSE>'bQ._DESCRIPTION='utility-belt library for functional programming in Lua'return bQ end
