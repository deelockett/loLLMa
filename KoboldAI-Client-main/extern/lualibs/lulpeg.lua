-- LuLPeg @a10d246290254ab5c206ed9df1394db9275166ab | /lulpeg.lua | https://github.com/pygy/LuLPeg | License: Public-domain-equivalent except for /src/re.lua, which is MIT-licensed | Minified using https://www.npmjs.com/package/luamin/v/1.0.4 and then the following regex replacement was used on the output: /(\([^()]+?\))(\([^()]+?or[^()]+?\)\([^()]+?\))/ was replaced with "\1;\2" (without the quotes)
-- Copyright (C) 2013 Lua.org, PUC-Rio.
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
-- The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
local _ENV,a,b,c,d=_ENV or _G,{},{},true,require;local function require(...)local e=...if a[e]then return a[e]elseif b[e]then a[e]=b[e](e)return a[e]else return d(e)end end;do local _ENV=_ENV;b['util']=function(...)local getmetatable,setmetatable,load,loadstring,next,pairs,pcall,print,rawget,rawset,select,tostring,type,unpack=getmetatable,setmetatable,load,loadstring,next,pairs,pcall,print,rawget,rawset,select,tostring,type,unpack;local f,g,h=require"math",require"string",require"table"local i,j,k,l,m=f.max,g.match,g.gsub,h.concat,h.insert;local n=require"compat"local function o()end;local p,q,r;if pcall and not n.lua52 and not c then local function s(t,u)error("illegal global read: "..tostring(u),2)end;local function v(t,u,w)error("illegal global write: "..tostring(u)..": "..tostring(w),2)end;local x=setmetatable({},{__index=s,__newindex=v})p=function()pcall(setfenv,3,x)end;function q(y)rawget(x,y)end;function r(y,w)rawset(x,y,w)end else p=o end;local _ENV=p()local z={nop=o,noglobals=p,getglobal=q,setglobal=r}z.unpack=h.unpack or unpack;z.pack=h.pack or function(...)return{n=select('#',...),...}end;if n.lua51 then local A=load;function z.load(B,C,D,x)local E;if type(B)=='string'then E=loadstring(B)else E=A(B,C)end;if x then setfenv(E,x)end;return E end else z.load=load end;if n.luajit and n.jit then function z.max(F)local G=0;for u=1,#F do G=i(G,F[u])end;return G end elseif n.luajit then local H=z.unpack;function z.max(F)local I=#F;if I<=30 or I>10240 then local G=0;for u=1,#F do local J=F[u]if J>G then G=J end end;return G else return i(H(F))end end else local H=z.unpack;local K=1000;function z.max(L)local I=#L;if I==0 then return-1 end;local M=1;local N=K;local G=L[1]repeat if N>I then N=I end;local O=i(H(L,M,N))if O>G then G=O end;M=M+K;N=N+K until M>=I;return G end end;local function P(h,D)local Q=getmetatable(h)or{}if Q.__mode then error("The mode has already been set on table "..tostring(h)..".")end;Q.__mode=D;return setmetatable(h,Q)end;z.setmode=P;function z.weakboth(h)return P(h,"kv")end;function z.weakkey(h)return P(h,"k")end;function z.weakval(h)return P(h,"v")end;function z.strip_mt(h)return setmetatable(h,nil)end;local R;do local S,T=0,{}function R(w)if not T[w]then S=S+1;T[w]=S end;return T[w]end end;z.getuniqueid=R;do local U=0;function z.gensym()U=U+1;return"___SYM_"..U end end;function z.passprint(...)print(...)return...end;local V,W,X,Y,Z;local _=2;local function a0(w,a1)a1=a1 or 0;Z={}local a2={}V(w,a2,a1,a1)local a3=l(a2,"")return a3 end;z.val_to_str=a0;function V(w,a2,a1,a4)a4=a4 or 1;if"string"==type(w)then w=k(w,"\n","\n"..(" "):rep(a1*_+a4))if j(k(w,"[^'\"]",""),'^"+$')then a2[#a2+1]=l{"'","",w,"'"}else a2[#a2+1]=l{'"',k(w,'"','\\"'),'"'}end elseif"cdata"==type(w)then Y(w,a2,a1)elseif"table"==type(w)then if Z[w]then a2[#a2+1]=Z[w]else Z[w]=tostring(w)X(w,a2,a1)end else a2[#a2+1]=tostring(w)end end;function W(y,a2,a1)if"string"==type(y)and j(y,"^[_%a][_%a%d]*$")then a2[#a2+1]=k(y,"\n",(" "):rep(a1*_+1).."\n")else a2[#a2+1]="[ "V(y,a2,a1)a2[#a2+1]=" ]"end end;function Y(w,a2,a1)a2[#a2+1]=(" "):rep(a1*_)a2[#a2+1]="["print(#a2)for u=0,#w do if u%16==0 and u~=0 then a2[#a2+1]="\n"a2[#a2+1]=(" "):rep(a1*_+2)end;a2[#a2+1]=w[u]and 1 or 0;a2[#a2+1]=u~=#w and", "or""end;print(#a2,a2[1],a2[2])a2[#a2+1]="]"end;function X(a5,a2,a1)a2[#a2+1]=Z[a5]a2[#a2+1]="{\n"for y,w in pairs(a5)do local a4=1;a2[#a2+1]=(" "):rep((a1+1)*_)W(y,a2,a1+1)if a2[#a2]==" ]"and a2[#a2-2]=="[ "then a4=8+#a2[#a2-1]end;a2[#a2+1]=" = "V(w,a2,a1+1,a4)a2[#a2+1]="\n"end;a2[#a2+1]=(" "):rep(a1*_)a2[#a2+1]="}"end;function z.expose(w)print(a0(w))return w end;function z.map(F,a6,...)if type(F)=="function"then F,a6=a6,F end;local a3={}for u=1,#F do a3[u]=a6(F[u],...)end;return a3 end;function z.selfmap(F,a6,...)if type(F)=="function"then F,a6=a6,F end;for u=1,#F do F[u]=a6(F[u],...)end;return F end;local function a7(a5,a6,...)if type(a5)=="function"then a5,a6=a6,a5 end;local a3={}for y,w in next,a5 do a3[y]=a6(w,...)end;return a3 end;z.map_all=a7;local function a8(F,a6,a2)local a9=1;if not a2 then a2=F[1]a9=2 end;for u=a9,#F do a2=a6(a2,F[u])end;return a2 end;z.fold=a8;local function aa(F,a6,a2)local ab=0;if not a2 then a2=F[#F]ab=1 end;for u=#F-ab,1,-1 do a2=a6(F[u],a2)end;return a2 end;z.foldr=aa;local function ac(F,ad,ae,a2)local a9=1;if not a2 then a2=ad(F[1])a9=2 end;for u=a9,#F do a2=ae(a2,ad(F[u]))end;return a2 end;z.map_fold=ac;local function af(F,ad,ae,a2)local ab=0;if not a2 then a2=ad(F[#a2])ab=1 end;for u=#F-ab,1,-1 do a2=ae(ad(F[u],a2))end;return a2 end;z.map_foldr=ac;function z.zip(ag,ah)local a3,I={},i(#ag,#ah)for u=1,I do a3[u]={ag[u],ah[u]}end;return a3 end;function z.zip_all(ai,aj)local a3={}for y,w in pairs(ai)do a3[y]={w,aj[y]}end;for y,w in pairs(aj)do if a3[y]==nil then a3[y]={ai[y],w}end end;return a3 end;function z.filter(F,a6)local a3={}for u=1,#F do if a6(F[u])then m(a3,F[u])end end end;local function ak(...)return...end;z.id=ak;local function al(am,an)return am and an end;local function ao(am,an)return am or an end;function z.copy(a5)return a7(a5,ak)end;function z.all(F,ad)if ad then return ac(F,ad,al)else return a8(F,al)end end;function z.any(F,ad)if ad then return ac(F,ad,ao)else return a8(F,ao)end end;function z.get(ap)return function(a5)return a5[ap]end end;function z.lt(aq)return function(ar)return ar<aq end end;function z.compose(as,at)return function(...)return as(at(...))end end;function z.extend(au,...)for u=1,select('#',...)do for y,w in pairs(select(u,...))do au[y]=w end end;return au end;function z.setify(h)local av={}for u=1,#h do av[h[u]]=true end;return av end;function z.arrayify(...)return{...}end;local function aw(g)return g..""end;function z.checkstring(g,a6)local success,ax=pcall(aw,g)if not success then if a6==nil then a6="?"end;error("bad argument to '"..tostring(a6).."' (string expected, got "..type(g)..")",2)end;return ax end;return z end end;do local _ENV=_ENV;b['compiler']=function(...)local assert,error,pairs,print,rawset,select,setmetatable,tostring,type=assert,error,pairs,print,rawset,select,setmetatable,tostring,type;local g,h,ay=require"string",require"table",require"util"local _ENV=ay.noglobals()local az,aA,l,m,aB,H=g.byte,g.sub,h.concat,h.insert,h.remove,ay.unpack;local load,aC,a7,aD=ay.load,ay.map,ay.map_all,ay.pack;local aE=ay.expose;return function(aF,aG)local aH,aI=aG.evaluate,aG.ispattern;local aJ=aF.charset;local aK={}local function aL(aM,aN)if not aI(aM)then error("pattern expected")end;local aO=aM.pkind;if aO=="grammar"then aN={}elseif aO=="ref"or aO=="choice"or aO=="sequence"then if not aN[aM]then aN[aM]=aK[aO](aM,aN)end;return aN[aM]end;if not aM.compiled then aM.compiled=aK[aM.pkind](aM,aN)end;return aM.compiled end;aG.compile=aL;local function aP(F,aQ)for u=aQ,#F do F[u]=nil end end;local aR,aS,aT=aG.compile,aG.evaluate,aG.P;local function aU(u,I)if u==0 or u==1 or u==nil then return 1 elseif type(u)~="number"then error"number or nil expected for the stating index"elseif u>0 then return u>I and I+1 or u else return I+u<0 and 1 or I+u+1 end end;local function aV()return{kind={},bounds={},openclose={},aux={}}end;local function aW(aX,aM,aY,aZ,...)if aX then print("@!!! Match !!!@",aM)end;aM=aT(aM)assert(type(aY)=="string","string expected for the match subject")aZ=aU(aZ,#aY)if aX then print(("-"):rep(30))print(aM.pkind)aG.pprint(aM)end;local a_=aL(aM,{})local b0=aV()local b1={grammars={},args={n=select('#',...),...},tags={}}local success,b2,aQ=a_(aY,aZ,b0,1,b1)if aX then print("!!! Done Matching !!! success: ",success,"final position",b2,"final cap index",aQ,"#caps",#b0.openclose)end;if success then aP(b0.kind,aQ)aP(b0.aux,aQ)if aX then print("trimmed cap index = ",#b0+1)aG.cprint(b0,aY,1)end;local b3,t,b4=aS(b0,aY,1,1)if aX then print("#values",b4)aE(b3)end;if b4==0 then return b2 else return H(b3,1,b4)end else if aX then print("Failed")end;return nil end end;function aG.match(...)return aW(false,...)end;function aG.dmatch(...)return aW(true,...)end;for t,w in pairs{"C","Cf","Cg","Cs","Ct","Clb","div_string","div_table","div_number","div_function"}do aK[w]=load(([=[
    local compile, expose, type, LL = ...
    return function (pt, ccache)
        local matcher, this_aux = compile(pt.pattern, ccache), pt.aux
        return function (sbj, si, caps, ci, state)
            local ref_ci = ci
            local kind, bounds, openclose, aux
                = caps.kind, caps.bounds, caps.openclose, caps.aux
            kind      [ci] = "XXXX"
            bounds    [ci] = si
            openclose [ci] = 0
            caps.aux       [ci] = (this_aux or false)
            local success
            success, si, ci
                = matcher(sbj, si, caps, ci + 1, state)
            if success then
                if ci == ref_ci + 1 then
                    caps.openclose[ref_ci] = si
                else
                    kind      [ci] = "XXXX"
                    bounds    [ci] = si
                    openclose [ci] = ref_ci - ci
                    aux       [ci] = this_aux or false
                    ci = ci + 1
                end
            else
                ci = ci - 1
            end
            return success, si, ci
        end
    end]=]):gsub("XXXX",w),w.." compiler")(aL,aE,type,aG)end;aK["Carg"]=function(aM,aN)local b5=aM.aux;return function(aY,aZ,b0,aQ,b6)if b6.args.n<b5 then error("reference to absent argument #"..b5)end;b0.kind[aQ]="value"b0.bounds[aQ]=aZ;if b6.args[b5]==nil then b0.openclose[aQ]=1/0;b0.aux[aQ]=1/0 else b0.openclose[aQ]=aZ;b0.aux[aQ]=b6.args[b5]end;return true,aZ,aQ+1 end end;for t,w in pairs{"Cb","Cc","Cp"}do aK[w]=load(([=[
    return function (pt, ccache)
        local this_aux = pt.aux
        return function (sbj, si, caps, ci, state)
            caps.kind      [ci] = "XXXX"
            caps.bounds    [ci] = si
            caps.openclose [ci] = si
            caps.aux       [ci] = this_aux or false
            return true, si, ci + 1
        end
    end]=]):gsub("XXXX",w),w.." compiler")(aE)end;aK["/zero"]=function(aM,aN)local a_=aL(aM.pattern,aN)return function(aY,aZ,b0,aQ,b6)local success,b7=a_(aY,aZ,b0,aQ,b6)aP(b0.aux,aQ)return success,b7,aQ end end;local function b8(u,...)return u,aD(...)end;aK["Cmt"]=function(aM,aN)local a_,a6=aL(aM.pattern,aN),aM.aux;return function(aY,aZ,b0,aQ,b6)local success,b9,ba=a_(aY,aZ,b0,aQ,b6)if not success then aP(b0.aux,aQ)return false,aZ,aQ end;local b2,b3;if ba==aQ then b2,b3=b8(a6(aY,b9,aA(aY,aZ,b9-1)))else aP(b0.aux,ba)aP(b0.kind,ba)local bb,t,bc=aH(b0,aY,aQ)b2,b3=b8(a6(aY,b9,H(bb,1,bc)))end;if not b2 then return false,aZ,aQ end;if b2==true then b2=b9 end;if type(b2)=="number"and aZ<=b2 and b2<=#aY+1 then local bd,be,bf,bg=b0.kind,b0.bounds,b0.openclose,b0.aux;for u=1,b3.n do bd[aQ]="value"be[aQ]=aZ;if b3[u]==nil then b0.openclose[aQ]=1/0;b0.aux[aQ]=1/0 else b0.openclose[aQ]=b2;b0.aux[aQ]=b3[u]end;aQ=aQ+1 end elseif type(b2)=="number"then error"Index out of bounds returned by match-time capture."else error("Match time capture must return a number, a boolean or nil".." as first argument, or nothing at all.")end;return true,b2,aQ end end;aK["string"]=function(aM,aN)local bh=aM.aux;local S=#bh;return function(aY,aZ,b0,aQ,b6)local bi=aZ-1;for u=1,S do local bj;bj=az(aY,bi+u)if bj~=bh[u]then return false,aZ,aQ end end;return true,aZ+S,aQ end end;aK["char"]=function(aM,aN)return load(([=[
        local s_byte, s_char = ...
        return function(sbj, si, caps, ci, state)
            local c, nsi = s_byte(sbj, si), si + 1
            if c ~= __C0__ then
                return false, si, ci
            end
            return true, nsi, ci
        end]=]):gsub("__C0__",tostring(aM.aux)))(az,("").char)end;local function bk(aY,aZ,b0,aQ,b6)return true,aZ,aQ end;aK["true"]=function(aM)return bk end;local function bl(aY,aZ,b0,aQ,b6)return false,aZ,aQ end;aK["false"]=function(aM)return bl end;local function bm(aY,aZ,b0,aQ,b6)return aZ>#aY,aZ,aQ end;aK["eos"]=function(aM)return bm end;local function bn(aY,aZ,b0,aQ,b6)local bo,t=az(aY,aZ),aZ+1;if bo then return true,aZ+1,aQ else return false,aZ,aQ end end;aK["one"]=function(aM)return bn end;aK["any"]=function(aM)local S=aM.aux;if S==1 then return bn else S=aM.aux-1;return function(aY,aZ,b0,aQ,b6)local b5=aZ+S;if b5<=#aY then return true,b5+1,aQ else return false,aZ,aQ end end end end;do local function bp(at)for y,w in pairs(at.aux)do if not aI(w)then error(("rule 'A' is not a pattern"):gsub("A",tostring(y)))end end end;aK["grammar"]=function(aM,aN)bp(aM)local bq=a7(aM.aux,aL,aN)local br=bq[1]return function(aY,aZ,b0,aQ,b6)m(b6.grammars,bq)local success,b7,aQ=br(aY,aZ,b0,aQ,b6)aB(b6.grammars)return success,b7,aQ end end end;local bs={kind={},bounds={},openclose={},aux={}}aK["behind"]=function(aM,aN)local a_,S=aL(aM.pattern,aN),aM.aux;return function(aY,aZ,b0,aQ,b6)if aZ<=S then return false,aZ,aQ end;local success=a_(aY,aZ-S,bs,aQ,b6)bs.aux={}return success,aZ,aQ end end;aK["range"]=function(aM)local bt=aM.aux;return function(aY,aZ,b0,aQ,b6)local bo,b7=az(aY,aZ),aZ+1;for u=1,#bt do local bu=bt[u]if bo and bu[bo]then return true,b7,aQ end end;return false,aZ,aQ end end;aK["set"]=function(aM)local g=aM.aux;return function(aY,aZ,b0,aQ,b6)local bo,b7=az(aY,aZ),aZ+1;if g[bo]then return true,b7,aQ else return false,aZ,aQ end end end;aK["range"]=aK.set;aK["ref"]=function(aM,aN)local bv=aM.aux;local aq;return function(aY,aZ,b0,aQ,b6)if not aq then if#b6.grammars==0 then error(("rule 'XXXX' used outside a grammar"):gsub("XXXX",tostring(bv)))elseif not b6.grammars[#b6.grammars][bv]then error(("rule 'XXXX' undefined in given grammar"):gsub("XXXX",tostring(bv)))end;aq=b6.grammars[#b6.grammars][bv]end;local success,b7,bw=aq(aY,aZ,b0,aQ,b6)return success,b7,bw end end;local bx=[=[
            success, si, ci = XXXX(sbj, si, caps, ci, state)
            if success then
                return true, si, ci
            else
            end]=]local function by(bd,aM,aN)if aM[2].pkind==bd then return aL(aM[1],aN),by(bd,aM[2],aN)else return aL(aM[1],aN),aL(aM[2],aN)end end;aK["choice"]=function(aM,aN)local bz={by("choice",aM,aN)}local bA,bB={},{}for u=1,#bz do local f="ch"..u;bA[#bA+1]=f;bB[#bA]=bx:gsub("XXXX",f)end;bA[#bA+1]="clear_captures"bz[#bA]=aP;local bC=l{"local ",l(bA,", "),[=[ = ...
        return function (sbj, si, caps, ci, state)
            local aux, success = caps.aux, false
            ]=],l(bB,"\n"),[=[--
            return false, si, ci
        end]=]}return load(bC,"Choice")(H(bz))end;local bD=[=[
            success, si, ci = XXXX(sbj, si, caps, ci, state)
            if not success then
                return false, ref_si, ref_ci
            end]=]aK["sequence"]=function(aM,aN)local bE={by("sequence",aM,aN)}local bA,bB={},{}for u=1,#bE do local f="seq"..u;bA[#bA+1]=f;bB[#bA]=bD:gsub("XXXX",f)end;bA[#bA+1]="clear_captures"bE[#bA]=aP;local bC=l{"local ",l(bA,", "),[=[ = ...
        return function (sbj, si, caps, ci, state)
            local ref_si, ref_ci, success = si, ci
            ]=],l(bB,"\n"),[=[
            return true, si, ci
        end]=]}return load(bC,"Sequence")(H(bE))end;aK["at most"]=function(aM,aN)local a_,b5=aL(aM.pattern,aN),aM.aux;b5=-b5;return function(aY,aZ,b0,aQ,b6)local success=true;for u=1,b5 do success,aZ,aQ=a_(aY,aZ,b0,aQ,b6)if not success then break end end;return true,aZ,aQ end end;aK["at least"]=function(aM,aN)local a_,b5=aL(aM.pattern,aN),aM.aux;if b5==0 then return function(aY,aZ,b0,aQ,b6)local bF,bG;while true do local success;bF,bG=aZ,aQ;success,aZ,aQ=a_(aY,aZ,b0,aQ,b6)if not success then aZ,aQ=bF,bG;break end end;return true,aZ,aQ end elseif b5==1 then return function(aY,aZ,b0,aQ,b6)local bF,bG;local success=true;success,aZ,aQ=a_(aY,aZ,b0,aQ,b6)if not success then return false,aZ,aQ end;while true do local success;bF,bG=aZ,aQ;success,aZ,aQ=a_(aY,aZ,b0,aQ,b6)if not success then aZ,aQ=bF,bG;break end end;return true,aZ,aQ end else return function(aY,aZ,b0,aQ,b6)local bF,bG;local success=true;for t=1,b5 do success,aZ,aQ=a_(aY,aZ,b0,aQ,b6)if not success then return false,aZ,aQ end end;while true do local success;bF,bG=aZ,aQ;success,aZ,aQ=a_(aY,aZ,b0,aQ,b6)if not success then aZ,aQ=bF,bG;break end end;return true,aZ,aQ end end end;aK["unm"]=function(aM,aN)if aM.pkind=="any"and aM.aux==1 then return bm end;local a_=aL(aM.pattern,aN)return function(aY,aZ,b0,aQ,b6)local success,t,t=a_(aY,aZ,b0,aQ,b6)return not success,aZ,aQ end end;aK["lookahead"]=function(aM,aN)local a_=aL(aM.pattern,aN)return function(aY,aZ,b0,aQ,b6)local success,t,t=a_(aY,aZ,b0,aQ,b6)return success,aZ,aQ end end end end end;do local _ENV=_ENV;b['datastructures']=function(...)local getmetatable,pairs,setmetatable,type=getmetatable,pairs,setmetatable,type;local f,h,ay=require"math",require"table",require"util"local n=require"compat"local bH;if n.luajit then bH=require"ffi"end;local _ENV=ay.noglobals()local bI,load,bJ=ay.extend,ay.load,ay.max;local i,l,m,bK=f.max,h.concat,h.insert,h.sort;local bL={}local bM,bN,bO;local bP={}local function bQ(bR)local av=setmetatable(load(l{"return{ [0]=false",(", false"):rep(bR)," }"})(),bP)return av end;if n.jit then local bS,bT={v={}}function bP.__index(g,u)if u==nil or u>g.upper then return nil end;return g.v[u]end;function bP.__len(g)return g.upper end;function bP.__newindex(g,u,w)g.v[u]=w end;bT=bH.metatype('struct { int upper; bool v[?]; }',bP)function bM(h)if type(h)=="number"then local a3=bT(h+1)a3.upper=h;return a3 end;local bR=bJ(h)bS.upper=bR;if bR>255 then error"bool_set overflow"end;local av=bT(bR+1)av.upper=bR;for u=1,#h do av[h[u]]=true end;return av end;function bN(g)return type(g)=="cdata"and bH.istype(g,bT)end;bO=bN else function bM(h)if type(h)=="number"then return bQ(h)end;local av=bQ(bJ(h))for u=1,#h do av[h[u]]=true end;return av end;function bN(g)return false end;function bO(g)return getmetatable(g)==bP end end;local function bU(bV,bW)bW=bV<=bW and bW or-1;local av=bM(bW)for u=bV,bW do av[u]=true end;return av end;local bX,bY={},{}local function bZ(g,b_)if type(g)=="number"then b_[g]=true;return b_ else return g end end;local function c0(am,an)bX[am]=nil;bY[an]=nil end;local function c1(am,an)local bR=i(type(am)=="number"and am or#am,type(an)=="number"and an or#an)local c2,c3=bZ(am,bX),bZ(an,bY)local a3=bM(bR)for u=0,bR do a3[u]=c2[u]or c3[u]or false end;c0(am,an)return a3 end;local function c4(am,an)local a3={}for u=0,255 do a3[u]=am[u]and not an[u]end;return a3 end;local function c5(g)local c6={}for u=0,255 do c6[#c6+1]=g[u]==true and u or nil end;return l(c6,", ")end;bL.binary={set={new=bM,union=c1,difference=c4,tostring=c5},Range=bU,isboolset=bN,isbyteset=bO,isset=bO}local c7={}local function c8(h)local av=setmetatable({},c7)for u=1,#h do av[h[u]]=true end;return av end;local function c9(am,a3)for y in pairs(am)do a3[y]=true end;return a3 end;local function ca(am,an)am,an=type(am)=="number"and c8{am}or am,type(an)=="number"and c8{an}or an;local a3=c8{}c9(am,a3)c9(an,a3)return a3 end;local function cb(am,an)local c6={}am,an=type(am)=="number"and c8{am}or am,type(an)=="number"and c8{an}or an;for cc in pairs(am)do if am[cc]and not an[cc]then c6[#c6+1]=cc end end;return c8(c6)end;local function cd(g)local c6={}for cc in pairs(g)do m(c6,cc)end;bK(c6)return l(c6,",")end;local function ce(g)return getmetatable(g)==c7 end;local function cf(br,cg)local c6={}for u=br,cg do c6[#c6+1]=u end;return c8(c6)end;bL.other={set={new=c8,union=ca,tostring=cd,difference=cb},Range=cf,isboolset=bN,isbyteset=bO,isset=ce,isrange=function(am)return false end}return function(aF,aG)local ch=(aF.options or{}).charset or"binary"if type(ch)=="string"then ch=ch=="binary"and"binary"or"other"else ch=ch.binary and"binary"or"other"end;return bI(aF,bL[ch])end end end;do local _ENV=_ENV;b['re']=function(...)return function(aF,aG)local tonumber,type,print,error=tonumber,type,print,error;local setmetatable=setmetatable;local f=aG;local ci=f;local Q=getmetatable(ci.P(0))local cj=_VERSION;if cj=="Lua 5.2"then _ENV=nil end;local ck=f.P(1)local cl={nl=f.P"\n"}local cm;local cn;local co;local function cp()ci.locale(cl)cl.a=cl.alpha;cl.c=cl.cntrl;cl.d=cl.digit;cl.g=cl.graph;cl.l=cl.lower;cl.p=cl.punct;cl.s=cl.space;cl.u=cl.upper;cl.w=cl.alnum;cl.x=cl.xdigit;cl.A=ck-cl.a;cl.C=ck-cl.c;cl.D=ck-cl.d;cl.G=ck-cl.g;cl.L=ck-cl.l;cl.P=ck-cl.p;cl.S=ck-cl.s;cl.U=ck-cl.u;cl.W=ck-cl.w;cl.X=ck-cl.x;cm={}cn={}co={}local Q={__mode="v"}setmetatable(cm,Q)setmetatable(cn,Q)setmetatable(co,Q)end;cp()local function cq(ak,cr)local bj=cr and cr[ak]if not bj then error("undefined name: "..ak)end;return bj end;local function cs(g,u)local ct=#g<u+20 and g:sub(u)or g:sub(u,u+20).."..."ct=("pattern error near '%s'"):format(ct)error(ct,2)end;local function cu(cv,b5)local cw=ci.P(true)while b5>=1 do if b5%2>=1 then cw=cw*cv end;cv=cv*cv;b5=b5/2 end;return cw end;local function cx(g,u,bj)if type(bj)~="string"then return nil end;local cy=#bj+u;if g:sub(u,cy-1)==bj then return cy else return nil end end;local bh=(cl.space+"--"*(ck-cl.nl)^0)^0;local bv=f.R("AZ","az","__")*f.R("AZ","az","__","09")^0;local cz=bh*"<-"local cA=f.P"/"+")"+"}"+":}"+"~}"+"|}"+bv*cz+-1;bv=f.C(bv)local cB=bv*f.Carg(1)local cC=f.C(f.R"09"^1)*bh/tonumber;local cD="'"*f.C((ck-"'")^0)*"'"+'"'*f.C((ck-'"')^0)*'"'local cE="%"*cB/function(bj,cF)local cG=cF and cF[bj]or cl[bj]if not cG then error("name '"..bj.."' undefined")end;return cG end;local cH=f.Cs(ck*f.P"-"/""*(ck-"]"))/ci.R;local cI=cE+cH+f.C(ck)local cJ="["*f.C(f.P"^"^-1)*f.Cf(cI*(cI-"]")^0,Q.__add)/function(bj,cv)return bj=="^"and ck-cv or cv end*"]"local function cK(h,y,cL)if h[y]then error("'"..y.."' already defined as a rule")else h[y]=cL end;return h end;local function cM(b5,bu)return cK({b5},b5,bu)end;local function cN(b5,an)if not an then error("rule '"..b5 .."' used outside a grammar")else return ci.V(b5)end end;local cL=f.P{"Exp",Exp=bh*(f.V"Grammar"+f.Cf(f.V"Seq"*("/"*bh*f.V"Seq")^0,Q.__add)),Seq=f.Cf(f.Cc(f.P"")*f.V"Prefix"^0,Q.__mul)*(f.L(cA)+cs),Prefix="&"*bh*f.V"Prefix"/Q.__len+"!"*bh*f.V"Prefix"/Q.__unm+f.V"Suffix",Suffix=f.Cf(f.V"Primary"*bh*((f.P"+"*f.Cc(1,Q.__pow)+f.P"*"*f.Cc(0,Q.__pow)+f.P"?"*f.Cc(-1,Q.__pow)+"^"*(f.Cg(cC*f.Cc(cu))+f.Cg(f.C(f.S"+-"*f.R"09"^1)*f.Cc(Q.__pow)))+"->"*bh*(f.Cg((cD+cC)*f.Cc(Q.__div))+f.P"{}"*f.Cc(nil,f.Ct)+f.Cg(cB/cq*f.Cc(Q.__div)))+"=>"*bh*f.Cg(cB/cq*f.Cc(f.Cmt)))*bh)^0,function(am,an,as)return as(am,an)end),Primary="("*f.V"Exp"*")"+cD/ci.P+cJ+cE+"{:"*(bv*":"+f.Cc(nil))*f.V"Exp"*":}"/function(b5,cv)return ci.Cg(cv,b5)end+"="*bv/function(b5)return ci.Cmt(ci.Cb(b5),cx)end+f.P"{}"/ci.Cp+"{~"*f.V"Exp"*"~}"/ci.Cs+"{|"*f.V"Exp"*"|}"/ci.Ct+"{"*f.V"Exp"*"}"/ci.C+f.P"."*f.Cc(ck)+(bv*-cz+"<"*bv*">")*f.Cb("G")/cN,Definition=bv*cz*f.V"Exp",Grammar=f.Cg(f.Cc(true),"G")*f.Cf(f.V"Definition"/cM*f.Cg(f.V"Definition")^0,cK)/ci.P}local cO=bh*f.Cg(f.Cc(false),"G")*cL/ci.P*(-ck+cs)local function aL(cv,cr)if ci.type(cv)=="pattern"then return cv end;local cP=cO:match(cv,1,cr)if not cP then error("incorrect pattern",3)end;return cP end;local function cQ(g,cv,u)local cP=cm[cv]if not cP then cP=aL(cv)cm[cv]=cP end;return cP:match(g,u or 1)end;local function cR(g,cv,u)local cP=cn[cv]if not cP then cP=aL(cv)/0;cP=ci.P{ci.Cp()*cP*ci.Cp()+1*ci.V(1)}cn[cv]=cP end;local u,cy=cP:match(g,u or 1)if u then return u,cy-1 else return u end end;local function cS(g,cv,cT)local at=co[cv]or{}co[cv]=at;local cP=at[cT]if not cP then cP=aL(cv)cP=ci.Cs((cP/cT+1)^0)at[cT]=cP end;return cP:match(g)end;local cU={compile=aL,match=cQ,find=cR,gsub=cS,updatelocale=cp}return cU end end end;do local _ENV=_ENV;b['charsets']=function(...)local g,h,ay=require"string",require"table",require"util"local _ENV=ay.noglobals()local cV=ay.copy;local cW,aA,az,l,m=g.char,g.sub,g.byte,h.concat,h.insert;local function cX(cY)if cY<128 then return 0,cY elseif cY<192 then error("Byte values between 0x80 to 0xBF cannot start a multibyte sequence")elseif cY<224 then return 1,cY-192 elseif cY<240 then return 2,cY-224 elseif cY<248 then return 3,cY-240 elseif cY<252 then return 4,cY-248 elseif cY<254 then return 5,cY-252 else error("Byte values between 0xFE and OxFF cannot start a multibyte sequence")end end;local function cZ(c_,br,cg)br=br or 1;cg=cg or#c_;local ab,bo=0;for u=br,cg do local an=az(c_,u)if ab==0 then bo=u;success,ab=pcall(cX,an)if not success then return false,bo-1 end else if not(127<an and an<192)then return false,bo-1 end;ab=ab-1 end end;if ab~=0 then return nil,bo-1 end;return true,cg end;local function d0(c_,u)u=u and u+1 or 1;if u>#c_ then return end;local bj=az(c_,u)local ab,ar=cX(bj)for u=u+1,u+ab do bj=az(c_,u)ar=ar*64+bj-128 end;return u+ab,u,ar end;local function d1(c_,u)u=u and u+1 or 1;if u>#c_ then return end;local ab=cX(az(c_,u))return u+ab,u,aA(c_,u,u+ab)end;local function d2(c_)local d3={}for t,t,bj in d0,c_ do m(d3,bj)end;return d3 end;local function d4(c_)local d3={}for t,t,bj in d1,c_ do m(d3,bj)end;return d3 end;local function d5(c_,u)if u>#c_ then return end;local bj=az(c_,u)local ab,ar=cX(bj)for u=u+1,u+ab do bj=az(c_,u)ar=ar*64+bj-128 end;return ar,u+ab+1 end;local function d6(d7)if not d7 then return end;return function(c_)local a3={}local d8,u=true;while d8 do d8,u=d7(c_,u)a3[#a3]=d8 end;return a3 end end;local function d9(bo)if not bo then return end;return function(F)local a3={}for u=1,#F do m(a3,bo(F[u]))end;return l(a3)end end;local function da(c_,u)local cY,db,dc,dd,de,df=az(c_,u)if cY<128 then return cY,u+1 elseif cY<192 then error("Byte values between 0x80 to 0xBF cannot start a multibyte sequence")elseif cY<224 then return(cY-192)*64+az(c_,u+1),u+2 elseif cY<240 then de,df=az(c_,u+1,u+2)return(cY-224)*4096+de%64*64+df%64,u+3 elseif cY<248 then dd,de,df=az(c_,u+1,u+2,1+3)return(cY-240)*262144+dd%64*4096+de%64*64+df%64,u+4 elseif cY<252 then dc,dd,de,df=az(c_,u+1,u+2,1+3,u+4)return(cY-248)*16777216+dc%64*262144+dd%64*4096+de%64*64+df%64,u+5 elseif cY<254 then db,dc,dd,de,df=az(c_,u+1,u+2,1+3,u+4,u+5)return(cY-252)*1073741824+db%64*16777216+dc%64*262144+dd%64*4096+de%64*64+df%64,u+6 else error("Byte values between 0xFE and OxFF cannot start a multibyte sequence")end end;local function dg(c_,u)if u>#c_ then return end;local ab=cX(az(c_,u))return aA(c_,u,u+ab),u+ab+1 end;local function dh(bj)if bj<128 then return cW(bj)elseif bj<2048 then return cW(192+bj/64,128+bj%64)elseif bj<55296 or 57343<bj and bj<65536 then return cW(224+bj/4096,128+bj/64%64,128+bj%64)elseif bj<2097152 then return cW(240+bj/262144,128+bj/4096%64,128+bj/64%64,128+bj%64)elseif bj<67108864 then return cW(248+bj/16777216,128+bj/262144%64,128+bj/4096%64,128+bj/64%64,128+bj%64)elseif bj<2147483648 then return cW(252+bj/1073741824,128+bj/16777216%64,128+bj/262144%64,128+bj/4096%64,128+bj/64%64,128+bj%64)end;error("Bad Unicode code point: "..bj..".")end;local function di(c_,br,cg)br=br or 1;cg=cg or#c_;return true,cg end;local function dj(c_,u)u=u and u+1 or 1;if u>=#c_ then return end;return u,u,aA(c_,u,u)end;local function dk(c_,u)u=u and u+1 or 1;if u>#c_ then return end;return u,u,az(c_,u)end;local function dl(c_)local d3={}for u=1,#c_ do m(d3,az(c_,u))end;return d3 end;local function dm(c_)local d3={}for u=1,#c_ do m(d3,aA(c_,u,u))end;return d3 end;local function dn(c_,u)return az(c_,u),u+1 end;local function dp(c_,u)return aA(c_,u,u),u+1 end;local dq={binary={name="binary",binary=true,validate=di,split_char=dm,split_int=dl,next_char=dk,next_int=dj,get_char=dp,get_int=dn,tochar=cW},["UTF-8"]={name="UTF-8",validate=cZ,split_char=d4,split_int=d2,next_char=d1,next_int=d0,get_char=dg,get_int=d5}}return function(aF)local ch=aF.options.charset or"binary"if dq[ch]then aF.charset=cV(dq[ch])aF.binary_split_int=dl else error("NYI: custom charsets")end end end end;do local _ENV=_ENV;b['evaluator']=function(...)local select,tonumber,tostring,type=select,tonumber,tostring,type;local g,h,ay=require"string",require"table",require"util"local aA,l=g.sub,h.concat;local H=ay.unpack;local _ENV=ay.noglobals()return function(aF,aG)local dr={}local function ds(b0,aY,dt,aQ,b4)local bf,bd=b0.openclose,b0.kind;while bd[aQ]and bf[aQ]>=0 do aQ,b4=dr[bd[aQ]](b0,aY,dt,aQ,b4)end;return aQ,b4 end;function dr.C(b0,aY,dt,aQ,b4)if b0.openclose[aQ]>0 then dt[b4]=aA(aY,b0.bounds[aQ],b0.openclose[aQ]-1)return aQ+1,b4+1 end;dt[b4]=false;local du,dv=ds(b0,aY,dt,aQ+1,b4+1)dt[b4]=aA(aY,b0.bounds[aQ],b0.bounds[du]-1)return du+1,dv end;local function dw(b0,dx,aQ)local bg,bf,bd=b0.aux,b0.openclose,b0.kind;repeat aQ=aQ-1;local dy,dz=bg[aQ],bf[aQ]if dz<0 then aQ=aQ+dz end;if dz~=0 and bd[aQ]=="Clb"and dx==dy then return aQ end until aQ==1;dx=type(dx)=="string"and"'"..dx.."'"or tostring(dx)error("back reference "..dx.." not found")end;function dr.Cb(b0,aY,dt,aQ,b4)local dA=dw(b0,b0.aux[aQ],aQ)dA,b4=dr.Cg(b0,aY,dt,dA,b4)return aQ+1,b4 end;function dr.Cc(b0,aY,dt,aQ,b4)local dB=b0.aux[aQ]for u=1,dB.n do b4,dt[b4]=b4+1,dB[u]end;return aQ+1,b4 end;dr["Cf"]=function()error("NYI: Cf")end;function dr.Cf(b0,aY,dt,aQ,b4)if b0.openclose[aQ]>0 then error"No First Value"end;local a6,dC,dD=b0.aux[aQ],{}aQ=aQ+1;aQ,dD=dr[b0.kind[aQ]](b0,aY,dC,aQ,1)if dD==1 then error"No first value"end;local dE=dC[1]while b0.kind[aQ]and b0.openclose[aQ]>=0 do aQ,dD=dr[b0.kind[aQ]](b0,aY,dC,aQ,1)dE=a6(dE,H(dC,1,dD-1))end;dt[b4]=dE;return aQ+1,b4+1 end;function dr.Cg(b0,aY,dt,aQ,b4)if b0.openclose[aQ]>0 then dt[b4]=aA(aY,b0.bounds[aQ],b0.openclose[aQ]-1)return aQ+1,b4+1 end;local du,dv=ds(b0,aY,dt,aQ+1,b4)if dv==b4 then dt[dv]=aA(aY,b0.bounds[aQ],b0.bounds[du]-1)dv=dv+1 end;return du+1,dv end;function dr.Clb(b0,aY,dt,aQ,b4)local dz=b0.openclose;if dz[aQ]>0 then return aQ+1,b4 end;local dF=0;repeat if dz[aQ]==0 then dF=dF+1 elseif dz[aQ]<0 then dF=dF-1 end;aQ=aQ+1 until dF==0;return aQ,b4 end;function dr.Cp(b0,aY,dt,aQ,b4)dt[b4]=b0.bounds[aQ]return aQ+1,b4+1 end;function dr.Ct(b0,aY,dt,aQ,b4)local bg,bf,bd=b0.aux,b0.openclose,b0.kind;local dG={}dt[b4]=dG;if bf[aQ]>0 then return aQ+1,b4+1 end;local dH,dI=1,{}aQ=aQ+1;while bd[aQ]and bf[aQ]>=0 do if bd[aQ]=="Clb"then local dx,dJ=bg[aQ],1;aQ,dJ=dr.Cg(b0,aY,dI,aQ,1)if dJ~=1 then dG[dx]=dI[1]end else aQ,dH=dr[bd[aQ]](b0,aY,dG,aQ,dH)end end;return aQ+1,b4+1 end;local dK=1/0;function dr.value(b0,aY,dt,aQ,b4)local ar;if b0.aux[aQ]~=dK or b0.openclose[aQ]~=dK then ar=b0.aux[aQ]end;dt[b4]=ar;return aQ+1,b4+1 end;function dr.Cs(b0,aY,dt,aQ,b4)if b0.openclose[aQ]>0 then dt[b4]=aA(aY,b0.bounds[aQ],b0.openclose[aQ]-1)else local be,bd,bf=b0.bounds,b0.kind,b0.openclose;local br,dL,dM,dN,dO=be[aQ],{},{},1,1;local dP;aQ=aQ+1;while bf[aQ]>=0 do dP=be[aQ]dL[dN]=aA(aY,br,dP-1)dN=dN+1;aQ,dO=dr[bd[aQ]](b0,aY,dM,aQ,1)if dO>1 then dL[dN]=dM[1]dN=dN+1;br=bf[aQ-1]>0 and bf[aQ-1]or be[aQ-1]else br=dP end end;dL[dN]=aA(aY,br,be[aQ]-1)dt[b4]=l(dL)end;return aQ+1,b4+1 end;local function dQ(a2,dR,...)local b5=select('#',...)for u=1,b5 do dR,a2[dR]=dR+1,select(u,...)end;return dR end;function dr.div_function(b0,aY,dt,aQ,b4)local a6=b0.aux[aQ]local dS,dT;if b0.openclose[aQ]>0 then dS,dT={aA(aY,b0.bounds[aQ],b0.openclose[aQ]-1)},2 else dS={}aQ,dT=ds(b0,aY,dS,aQ+1,1)end;aQ=aQ+1;b4=dQ(dt,b4,a6(H(dS,1,dT-1)))return aQ,b4 end;function dr.div_number(b0,aY,dt,aQ,b4)local dU=b0.aux[aQ]local dV,dW;if b0.openclose[aQ]>0 then dV,dW={aA(aY,b0.bounds[aQ],b0.openclose[aQ]-1)},2 else dV={}aQ,dW=ds(b0,aY,dV,aQ+1,1)end;aQ=aQ+1;if dU>=dW then error("no capture '"..dU.."' in /number capture.")end;dt[b4]=dV[dU]return aQ,b4+1 end;local function dX(b0,aQ)local dY=b0.openclose;local dZ={open=b0.bounds[aQ]}if dY[aQ]>0 then dZ.close=dY[aQ]return aQ+1,dZ,0 end;local d_=aQ;local dF=1;aQ=aQ+1;repeat local dz=dY[aQ]if dF==1 and dz>=0 then dZ[#dZ+1]=aQ end;if dz==0 then dF=dF+1 elseif dz<0 then dF=dF-1 end;aQ=aQ+1 until dF==0;dZ.close=b0.bounds[aQ-1]return aQ,dZ,#dZ end;function dr.div_string(b0,aY,dt,aQ,b4)local b5,dZ;local e0;local e0,e1={},{}local e2=b0.aux[aQ]aQ,dZ,b5=dX(b0,aQ)dt[b4]=e2:gsub("%%([%d%%])",function(e3)if e3=="%"then return"%"end;e3=tonumber(e3)if not e0[e3]then if e3>b5 then error("no capture at index "..e3 .." in /string capture.")end;if e3==0 then e0[e3]=aA(aY,dZ.open,dZ.close-1)else local t,b4=dr[b0.kind[dZ[e3]]](b0,aY,e1,dZ[e3],1)if b4==1 then error("no values in capture at index"..e3 .." in /string capture.")end;e0[e3]=e1[1]end end;return e0[e3]end)return aQ,b4+1 end;function dr.div_table(b0,aY,dt,aQ,b4)local dU=b0.aux[aQ]local e4;if b0.openclose[aQ]>0 then e4=aA(aY,b0.bounds[aQ],b0.openclose[aQ]-1)else local e5,t={}aQ,t=ds(b0,aY,e5,aQ+1,1)e4=e5[1]end;aQ=aQ+1;if dU[e4]then dt[b4]=dU[e4]return aQ,b4+1 else return aQ,b4 end end;function aG.evaluate(b0,aY,aQ)local dt={}local t,b4=ds(b0,aY,dt,aQ,1)return dt,1,b4-1 end end end end;do local _ENV=_ENV;b['printers']=function(...)return function(aF,aG)local ipairs,pairs,print,tostring,type=ipairs,pairs,print,tostring,type;local g,h,ay=require"string",require"table",require"util"local e6=aF.set.tostring;local _ENV=ay.noglobals()local cW,aA,l=g.char,g.sub,h.concat;local aE,load,aC=ay.expose,ay.load,ay.map;local e7={["\f"]="\\f",["\n"]="\\n",["\r"]="\\r",["\t"]="\\t",["\v"]="\\v",["\127"]="\\ESC"}local function by(bd,c6)if c6[2].pkind==bd then return c6[1],by(bd,c6[2])else return c6[1],c6[2]end end;for u=0,8 do e7[cW(u)]="\\"..u end;for u=14,31 do e7[cW(u)]="\\"..u end;local function e8(ax)return ax:gsub("%c",e7)end;local function e9(av)return cW(load("return "..e6(av))())end;local ea={}local function eb(aM,ab,ec)return ea[aM.pkind](aM,ab,ec)end;function aG.pprint(ed)local aM=aG.P(ed)print"\nPrint pattern"eb(aM,"","")print"--- /pprint\n"return ed end;for y,w in pairs{string=[[ "P( \""..escape(pt.as_is).."\" )"       ]],char=[[ "P( \""..escape(to_char(pt.aux)).."\" )"]],["true"]=[[ "P( true )"                     ]],["false"]=[[ "P( false )"                    ]],eos=[[ "~EOS~"                         ]],one=[[ "P( one )"                      ]],any=[[ "P( "..pt.aux.." )"             ]],set=[[ "S( "..'"'..escape(set_repr(pt.aux))..'"'.." )" ]],["function"]=[[ "P( "..pt.aux.." )"             ]],ref=[[
        "V( ",
            (type(pt.aux) == "string" and "\""..pt.aux.."\"")
                          or tostring(pt.aux)
        , " )"
        ]],range=[[
        "R( ",
            escape(t_concat(map(
                pt.as_is,
                function(e) return '"'..e..'"' end)
            , ", "))
        ," )"
        ]]}do ea[y]=load(([==[
        local k, map, t_concat, to_char, escape, set_repr = ...
        return function (pt, offset, prefix)
            print(t_concat{offset,prefix,XXXX})
        end
    ]==]):gsub("XXXX",w),y.." printer")(y,aC,l,cW,e8,e9)end;for y,w in pairs{["behind"]=[[ LL_pprint(pt.pattern, offset, "B ") ]],["at least"]=[[ LL_pprint(pt.pattern, offset, pt.aux.." ^ ") ]],["at most"]=[[ LL_pprint(pt.pattern, offset, pt.aux.." ^ ") ]],unm=[[LL_pprint(pt.pattern, offset, "- ")]],lookahead=[[LL_pprint(pt.pattern, offset, "# ")]],choice=[[
        print(offset..prefix.."+")
        local ch, i = {}, 1
        while pt.pkind == "choice" do
            ch[i], pt, i = pt[1], pt[2], i + 1
        end
        ch[i] = pt
        map(ch, LL_pprint, offset.." :", "")
        ]],sequence=[=[
        print(offset..prefix.."*")
        local acc, p2 = {}
        offset = offset .. " |"
        while true do
            if pt.pkind ~= "sequence" then -- last element
                if pt.pkind == "char" then
                    acc[#acc + 1] = pt.aux
                    print(offset..'P( "'..s.char(u.unpack(acc))..'" )')
                else
                    if #acc ~= 0 then
                        print(offset..'P( "'..s.char(u.unpack(acc))..'" )')
                    end
                    LL_pprint(pt, offset, "")
                end
                break
            elseif pt[1].pkind == "char" then
                acc[#acc + 1] = pt[1].aux
            elseif #acc ~= 0 then
                print(offset..'P( "'..s.char(u.unpack(acc))..'" )')
                acc = {}
                LL_pprint(pt[1], offset, "")
            else
                LL_pprint(pt[1], offset, "")
            end
            pt = pt[2]
        end
        ]=],grammar=[[
        print(offset..prefix.."Grammar")
        for k, pt in pairs(pt.aux) do
            local prefix = ( type(k)~="string"
                             and tostring(k)
                             or "\""..k.."\"" )
            LL_pprint(pt, offset.."  ", prefix .. " = ")
        end
    ]]}do ea[y]=load(([[
        local map, LL_pprint, pkind, s, u, flatten = ...
        return function (pt, offset, prefix)
            XXXX
        end
    ]]):gsub("XXXX",w),y.." printer")(aC,eb,type,g,ay,by)end;for t,ee in pairs{"C","Cs","Ct"}do ea[ee]=function(aM,ab,ec)print(ab..ec..ee)eb(aM.pattern,ab.."  ","")end end;for t,ee in pairs{"Cg","Clb","Cf","Cmt","div_number","/zero","div_function","div_table"}do ea[ee]=function(aM,ab,ec)print(ab..ec..ee.." "..tostring(aM.aux or""))eb(aM.pattern,ab.."  ","")end end;ea["div_string"]=function(aM,ab,ec)print(ab..ec..'/string "'..tostring(aM.aux or"")..'"')eb(aM.pattern,ab.."  ","")end;for t,ee in pairs{"Carg","Cp"}do ea[ee]=function(aM,ab,ec)print(ab..ec..ee.."( "..tostring(aM.aux).." )")end end;ea["Cb"]=function(aM,ab,ec)print(ab..ec.."Cb( \""..aM.aux.."\" )")end;ea["Cc"]=function(aM,ab,ec)print(ab..ec.."Cc("..l(aC(aM.aux,tostring),", ").." )")end;local ef={}local eg="   "local function eh(b5)b5=tostring(b5)b5=b5 .."."..(" "):rep(4-#b5)return b5 end;local function ei(b0,aQ,a1,aY,b5)local bf,bd=b0.openclose,b0.kind;a1=a1 or 0;while bd[aQ]and bf[aQ]>=0 do if b0.openclose[aQ]>0 then print(l({eh(b5),eg:rep(a1),b0.kind[aQ],": start = ",tostring(b0.bounds[aQ])," finish = ",tostring(b0.openclose[aQ]),b0.aux[aQ]and" aux = "or"",b0.aux[aQ]and(type(b0.aux[aQ])=="string"and'"'..tostring(b0.aux[aQ])..'"'or tostring(b0.aux[aQ]))or""," \t",aA(aY,b0.bounds[aQ],b0.openclose[aQ]-1)}))if type(b0.aux[aQ])=="table"then aE(b0.aux[aQ])end else local bd=b0.kind[aQ]local br=b0.bounds[aQ]print(l({eh(b5),eg:rep(a1),bd,": start = ",br,b0.aux[aQ]and" aux = "or"",b0.aux[aQ]and(type(b0.aux[aQ])=="string"and'"'..tostring(b0.aux[aQ])..'"'or tostring(b0.aux[aQ]))or""}))aQ,b5=ei(b0,aQ+1,a1+1,aY,b5+1)print(l({eh(b5),eg:rep(a1),"/",bd," finish = ",tostring(b0.bounds[aQ])," \t",aA(aY,br,(b0.bounds[aQ]or 1)-1)}))end;b5=b5+1;aQ=aQ+1 end;return aQ,b5 end;function aG.cprint(b0,aQ,aY)aQ=aQ or 1;print"\nCapture Printer:\n================"ei(b0,aQ,0,aY,1)print"================\n/Cprinter\n"end;return{pprint=aG.pprint,cprint=aG.cprint}end end end;do local _ENV=_ENV;b['analyzer']=function(...)local ay=require"util"local o,ej=ay.nop,ay.weakkey;local ek,el,em=ej{},ej{},ej{}return{hasV=o,hasCmt=o,length=o,hasCapture=o}end end;do local _ENV=_ENV;b['locale']=function(...)local bI=require"util".extend;local _ENV=require"util".noglobals()return function(aF,aG)local en,bh=aG.R,aG.S;local eo={}eo["cntrl"]=en"\0\31"+"\127"eo["digit"]=en"09"eo["lower"]=en"az"eo["print"]=en" ~"eo["space"]=bh" \f\n\r\t\v"eo["upper"]=en"AZ"eo["alpha"]=eo["lower"]+eo["upper"]eo["alnum"]=eo["alpha"]+eo["digit"]eo["graph"]=eo["print"]-eo["space"]eo["punct"]=eo["graph"]-eo["alnum"]eo["xdigit"]=eo["digit"]+en"af"+en"AF"function aG.locale(h)return bI(h or{},eo)end end end end;do local _ENV=_ENV;b['match']=function(...)end end;do local _ENV=_ENV;b['factorizer']=function(...)local ipairs,pairs,print,setmetatable=ipairs,pairs,print,setmetatable;local ay=require"util"local ak,o,ep,ej=ay.id,ay.nop,ay.setify,ay.weakkey;local _ENV=ay.noglobals()local function eq(am,an,er)local ak,es=er.id,er.brk;if am==ak then return true,an elseif an==ak then return true,am elseif am==es then return true,es else return false end end;local et=ep{"unm","lookahead","C","Cf","Cg","Cs","Ct","/zero"}local eu=ep{"behind","at least","at most","Clb","Cmt","div_string","div_number","div_table","div_function"}local ev=ep{"char","set","range"}local ew;ew=setmetatable({},{__mode="k",__index=function(self,aM)local bd,a3=aM.pkind,false;if bd=="Cmt"or bd=="ref"then a3=true elseif et[bd]or eu[bd]then a3=ew[aM.pattern]elseif bd=="choice"or bd=="sequence"then a3=ew[aM[1]]or ew[aM[2]]end;ew[aM]=a3;return a3 end})return function(aF,aG)if aF.options.factorize==false then return{choice=o,sequence=o,lookahead=o,unm=o}end;local ex,aT=aF.constructors,aG.P;local ey,ez=ex.constant.truept,ex.constant.falsept;local eA=aF.set.union;local eB=ep{"char","set"}local eC={["/zero"]="__div",["div_number"]="__div",["div_string"]="__div",["div_table"]="__div",["div_function"]="__div",["at least"]="__exp",["at most"]="__exp",["Clb"]="Cg"}local function eD(am,an)do local eE,a3=eq(am,an,{id=ez,brk=ey})if eE then return a3 end end;local eF,eG=am.pkind,an.pkind;if am==an and not ew[am]then return am elseif eF=="choice"then local a2,u={},1;while am.pkind=="choice"do a2[u],am,u=am[1],am[2],u+1 end;a2[u]=am;for J=u,1,-1 do an=a2[J]+an end;return an elseif eB[eF]and eB[eG]then return ex.aux("set",eA(am.aux,an.aux))elseif eB[eF]and eG=="any"and an.aux==1 or eB[eG]and eF=="any"and am.aux==1 then return eF=="any"and am or an elseif eF==eG then if(et[eF]or eu[eF])and am.aux==an.aux then return aG[eC[eF]or eF](am.pattern+an.pattern,am.aux)elseif eF==eG and eF=="sequence"then if am[1]==an[1]and not ew[am[1]]then return am[1]*(am[2]+an[2])end end end;return false end;local function eH(aM)return aM end;local function bE(am,an)do local eE,a3=eq(am,an,{id=ey,brk=ez})if eE then return a3 end end;local eF,eG=am.pkind,an.pkind;if eF=="sequence"then local a2,u={},1;while am.pkind=="sequence"do a2[u],am,u=am[1],am[2],u+1 end;a2[u]=am;for J=u,1,-1 do an=a2[J]*an end;return an elseif(eF=="one"or eF=="any")and(eG=="one"or eG=="any")then return aT(am.aux+an.aux)end;return false end;local function eI(aM)if aM==ey then return ez elseif aM==ez then return ey elseif aM.pkind=="unm"then return#aM.pattern elseif aM.pkind=="lookahead"then return-aM.pattern end end;return{choice=eD,lookahead=eH,sequence=bE,unm=eI}end end end;do local _ENV=_ENV;b['API']=function(...)local assert,error,ipairs,pairs,pcall,print,require,select,tonumber,tostring,type=assert,error,ipairs,pairs,pcall,print,require,select,tonumber,tostring,type;local h,ay=require"table",require"util"local _ENV=ay.noglobals()local l=h.concat;local eJ,cV,a8,load,ac,af,ep,aD,H=ay.checkstring,ay.copy,ay.fold,ay.load,ay.map_fold,ay.map_foldr,ay.setify,ay.pack,ay.unpack;local function eK(T,aJ)error("Character at position "..T+1 .." is not a valid "..aJ.." one.",2)end;return function(aF,aG)local ch=aF.charset;local ex,aI=aF.constructors,aG.ispattern;local ey,ez,eL=ex.constant.truept,ex.constant.falsept,ex.constant.Cppt;local eM,eN=ch.split_int,ch.validate;local cH,eO,eA,e6=aF.Range,aF.set.new,aF.set.union,aF.set.tostring;local eP,eQ,eR,eS;local function eT(bj)return ex.aux("char",bj)end;local function aT(...)local w,b5=...,select('#',...)if b5==0 then error"bad argument #1 to 'P' (value expected)"end;local aO=type(w)if aI(w)then return w elseif aO=="function"then return aG.Cmt("",w)elseif aO=="string"then local success,T=eN(w)if not success then eK(T,ch.name)end;if w==""then return ey end;return af(eM(w),eT,aF.sequence)elseif aO=="table"then local at=cV(w)if at[1]==nil then error("grammar has no initial rule")end;if not aI(at[1])then at[1]=aG.V(at[1])end;return ex.none("grammar",at)elseif aO=="boolean"then return w and ey or ez elseif aO=="number"then if w==0 then return ey elseif w>0 then return ex.aux("any",w)else return-ex.aux("any",-w)end else error("bad argument #1 to 'P' (lpeg-pattern expected, got "..aO..")")end end;aG.P=aT;local function eU(av)if av==""then return ez else local success;av=eJ(av,"S")return ex.aux("set",eO(eM(av)),av)end end;aG.S=eU;local function eV(...)if select('#',...)==0 then return aT(false)else local eW=cH(1,0)for t,bu in ipairs{...}do bu=eJ(bu,"R")assert(#bu==2,"bad argument #1 to 'R' (range must have two characters)")eW=eA(eW,cH(H(eM(bu))))end;return ex.aux("set",eW)end end;aG.R=eV;local function eX(bv)assert(bv~=nil)return ex.aux("ref",bv)end;aG.V=eX;do local eY=ep{"set","range","one","char"}local eZ=ep{"true","false","lookahead","unm"}local e_=ep{"Carg","Cb","C","Cf","Cg","Cs","Ct","/zero","Clb","Cmt","Cc","Cp","div_string","div_number","div_table","div_function","at least","at most","behind"}local function f0(aM,bq,f1)local aO=aM.pkind;if e_[aO]then return false elseif eY[aO]then return 1 elseif eZ[aO]then return 0 elseif aO=="string"then return#aM.as_is elseif aO=="any"then return aM.aux elseif aO=="choice"then local f2,f3=f0(aM[1],bq,f1),f0(aM[2],bq,f1)return f2==f3 and f2 elseif aO=="sequence"then local f2,f3=f0(aM[1],bq,f1),f0(aM[2],bq,f1)return f2 and f3 and f2+f3 elseif aO=="grammar"then if aM.aux[1].pkind=="ref"then return f0(aM.aux[aM.aux[1].aux],aM.aux,{})else return f0(aM.aux[1],aM.aux,{})end elseif aO=="ref"then if f1[aM]then return false end;f1[aM]=true;return f0(bq[aM.aux],bq,f1)else print(aO,"is not handled by fixedlen()")end end;function aG.B(aM)aM=aT(aM)local I=f0(aM)assert(I,"A 'behind' pattern takes a fixed length pattern as argument.")if I>=260 then error("Subpattern too long in 'behind' pattern constructor.")end;return ex.both("behind",aM,I)end end;local function f4(am,an)return tostring(am)..tostring(an)end;local function eD(am,an)local bv=tostring(am)..tostring(an)local f5=aF.ptcache.choice[bv]if not f5 then f5=eP(am,an)or ex.binary("choice",am,an)aF.ptcache.choice[bv]=f5 end;return f5 end;function aG.__add(am,an)return eD(aT(am),aT(an))end;local function bE(am,an)local bv=tostring(am)..tostring(an)local f6=aF.ptcache.sequence[bv]if not f6 then f6=eR(am,an)or ex.binary("sequence",am,an)aF.ptcache.sequence[bv]=f6 end;return f6 end;aF.sequence=bE;function aG.__mul(am,an)return bE(aT(am),aT(an))end;local function f7(aM)if aM==ey or aM==ez or aM.pkind=="unm"or aM.pkind=="lookahead"then return aM end;return ex.subpt("lookahead",aM)end;aG.__len=f7;aG.L=f7;local function f8(aM)return eS(aM)or ex.subpt("unm",aM)end;aG.__unm=f8;local function f9(am,an)am,an=aT(am),aT(an)return f8(an)*am end;aG.__sub=f9;local function fa(aM,b5)local success;success,b5=pcall(tonumber,b5)assert(success and type(b5)=="number","Invalid type encountered at right side of '^'.")return ex.both(b5<0 and"at most"or"at least",aM,b5)end;aG.__pow=fa;for t,ee in pairs{"C","Cs","Ct"}do aG[ee]=function(aM)aM=aT(aM)return ex.subpt(ee,aM)end end;aG["Cb"]=function(bg)return ex.aux("Cb",bg)end;aG["Carg"]=function(bg)assert(type(bg)=="number","Number expected as parameter to Carg capture.")assert(0<bg and bg<=200,"Argument out of bounds in Carg capture.")return ex.aux("Carg",bg)end;local function fb()return eL end;aG.Cp=fb;local function fc(...)return ex.none("Cc",aD(...))end;aG.Cc=fc;for t,ee in pairs{"Cf","Cmt"}do local ct="Function expected in "..ee.." capture"aG[ee]=function(aM,bg)assert(type(bg)=="function",ct)aM=aT(aM)return ex.both(ee,aM,bg)end end;local function fd(aM,fe)aM=aT(aM)if fe~=nil then return ex.both("Clb",aM,fe)else return ex.subpt("Cg",aM)end end;aG.Cg=fd;local ff=ep{"string","number","table","function"}local function fg(aM,bg)if aI(bg)then error"The right side of a '/' capture cannot be a pattern."elseif not ff[type(bg)]then error("The right side of a '/' capture must be of type ".."string, number, table or function.")end;local bv;if bg==0 then bv="/zero"else bv="div_"..type(bg)end;return ex.both(bv,aM,bg)end;aG.__div=fg;if aF.proxymt then for y,w in pairs(aG)do if y:match"^__"then aF.proxymt[y]=w end end else aG.__index=aG end;local fh=aF.factorizer(aF,aG)eP,eQ,eR,eS=fh.choice,fh.lookahead,fh.sequence,fh.unm end end end;do local _ENV=_ENV;b['constructors']=function(...)local getmetatable,ipairs,newproxy,print,setmetatable=getmetatable,ipairs,newproxy,print,setmetatable;local h,ay,n=require"table",require"util",require"compat"local l=h.concat;local cV,R,ak,aC,ej,fi=ay.copy,ay.getuniqueid,ay.id,ay.map,ay.weakkey,ay.weakval;local _ENV=ay.noglobals()local fj={constant={"Cp","true","false"},aux={"string","any","char","range","set","ref","sequence","choice","Carg","Cb"},subpt={"unm","lookahead","C","Cf","Cg","Cs","Ct","/zero"},both={"behind","at least","at most","Clb","Cmt","div_string","div_number","div_table","div_function"},none="grammar","Cc"}return function(aF,aG)local e6=aF.set.tostring;local fk,fl;if n.proxies and not n.lua52_len then local fm=ej{}local fn={__index=aG}local fo=newproxy(true)fl=getmetatable(fo)aF.proxymt=fl;function fl:__index(y)return fm[self][y]end;function fl:__newindex(y,w)fm[self][y]=w end;function aG.getdirect(cv)return fm[cv]end;function fk(fp)local aM=newproxy(fo)setmetatable(fp,fn)fm[aM]=fp;return aM end else if aG.warnings and not n.lua52_len then print("Warning: The `__len` metamethod won't work with patterns, ".."use `LL.L(pattern)` for lookaheads.")end;fl=aG;function aG.getdirect(cv)return cv end;function fk(aM)return setmetatable(aM,aG)end end;aF.newpattern=fk;local function aI(aM)return getmetatable(aM)==fl end;aG.ispattern=aI;function aG.type(aM)if aI(aM)then return"pattern"else return nil end end;local fq,fr;local function fs()fq,fr={},ej{}aF.ptcache=fq;for t,cv in ipairs(fj.aux)do fq[cv]=fi{}end;for t,cv in ipairs(fj.subpt)do fq[cv]=fi{}end;for t,cv in ipairs(fj.both)do fq[cv]={}end;return fq end;aG.resetptcache=fs;fs()local ex={}aF.constructors=ex;ex["constant"]={truept=fk{pkind="true"},falsept=fk{pkind="false"},Cppt=fk{pkind="Cp"}}local ft={string=function(bg,fu)return fu end,table=cV,set=function(bg,fu)return e6(bg)end,range=function(bg,fu)return l(fu,"|")end,sequence=function(bg,fu)return l(aC(R,bg),"|")end}ft.choice=ft.sequence;ex["aux"]=function(aO,bg,fu)local fv=fq[aO]local e4=(ft[aO]or ak)(bg,fu)if not fv[e4]then fv[e4]=fk{pkind=aO,aux=bg,as_is=fu}end;return fv[e4]end;ex["none"]=function(aO,bg)return fk{pkind=aO,aux=bg}end;ex["subpt"]=function(aO,aM)local fv=fq[aO]if not fv[aM]then fv[aM]=fk{pkind=aO,pattern=aM}end;return fv[aM]end;ex["both"]=function(aO,aM,bg)local fv=fq[aO][bg]if not fv then fq[aO][bg]=fi{}fv=fq[aO][bg]end;if not fv[aM]then fv[aM]=fk{pkind=aO,pattern=aM,aux=bg,cache=fv}end;return fv[aM]end;ex["binary"]=function(aO,am,an)return fk{am,an,pkind=aO}end end end end;do local _ENV=_ENV;b['init']=function(...)local getmetatable,setmetatable,pcall=getmetatable,setmetatable,pcall;local ay=require"util"local cV,aC,o,H=ay.copy,ay.map,ay.nop,ay.unpack;local fw,dq,fx,ex,fy,fz,fh,eo,ea,cU=H(aC(require,{"API","charsets","compiler","constructors","datastructures","evaluator","factorizer","locale","printers","re"}))local t,fA=pcall(require,"package")local _ENV=ay.noglobals()local fB="0.12"local fC="0.1.0"local function fD(self,x)setmetatable(x,{__index=self})end;local function fE(self,x)pcall(function()fA.loaded.lpeg=self;fA.loaded.re=self.re end)if x then x.lpeg,x.re=self,self.re end;return self end;local function fF(fG)fG=fG and cV(fG)or{}local aF,aG={options=fG,factorizer=fh},{new=fF,version=function()return fB end,luversion=function()return fC end,setmaxstack=o}aG.util=ay;aG.global=fD;aG.register=fE;dq(aF,aG)fy(aF,aG)ea(aF,aG)ex(aF,aG)fw(aF,aG)fz(aF,aG);(fG.compiler or fx)(aF,aG)eo(aF,aG)aG.re=cU(aF,aG)return aG end;local aG=fF()return aG end end;do local _ENV=_ENV;b['compat']=function(...)local t,fH,fI;t,fH=pcall(require,"debug")t,fI=pcall(require,"jit")fI=t and fI;local n={debug=fH,lua51=_VERSION=="Lua 5.1"and not fI,lua52=_VERSION=="Lua 5.2",luajit=fI and true or false,jit=fI and fI.status(),lua52_len=not#setmetatable({},{__len=function()end}),proxies=pcall(function()local fJ=newproxy(true)local fK=newproxy(fJ)assert(type(getmetatable(fJ))=="table"and getmetatable(fJ)==getmetatable(fK))end),_goto=not not loadstring or load"::R::"}return n end end;do local _ENV=_ENV;b['optimizer']=function(...)end end;return require"init"
