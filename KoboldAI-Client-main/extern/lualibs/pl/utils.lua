-- Penlight 1.11.0-1 | /lua/pl/utils.lua | https://github.com/lunarmodules/Penlight | License: MIT | Minified using https://www.npmjs.com/package/luamin/v/1.0.4
-- Copyright (C) 2009-2016 Steve Donovan, David Manura.
-- Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
-- The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
local a=string.format;local b=require'pl.compat'local c=io.stdout;local d=table.insert;local e=table.unpack;local f=b.is_windows;local g='default'local h;local i;local j={}local k={_VERSION="1.11.0"}for l,m in pairs(b)do k[l]=m end;k.patterns={FLOAT='[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*',INTEGER='[+%-%d]%d*',IDEN='[%a_][%w_]*',FILE='[%a%.\\][:%][%w%._%-\\]*'}k.stdmt={List={_name='List'},Map={_name='Map'},Set={_name='Set'},MultiMap={_name='MultiMap'}}k.pack=table.pack;function k.unpack(n,o,p)return e(n,o or 1,p or n.n or#n)end;function k.printf(q,...)k.assert_string(1,q)k.fprintf(c,q,...)end;function k.fprintf(r,q,...)k.assert_string(2,q)r:write(a(q,...))end;do local function s(t,l,m,u)local v=rawget(t,l)if v and l~='_M'and l~='_NAME'and l~='_PACKAGE'and l~='_VERSION'then k.fprintf(io.stderr,"warning: '%s.%s' will not override existing symbol\n",u,l)return end;rawset(t,l,m)end;local function w(t,n)for l,m in pairs(t)do if m==n then return l end end;return'?'end;local x={}function k.import(n,t)t=t or _G;n=n or k;if type(n)=='string'then n=require(n)end;local u=w(t,n)if x[n]then return end;x[n]=u;for l,m in pairs(n)do s(t,l,m,u)end end end;function k.choose(y,z,A)return y and z or A end;function k.array_tostring(n,B,C)B,C=B or{},C or tostring;for o=1,#n do B[o]=C(n[o],o)end;return B end;function k.is_type(D,E)if type(E)=='string'then return type(D)==E end;local F=getmetatable(D)return E==F end;function k.assert_arg(G,H,E,I,J,K)if type(H)~=E then error(("argument %d expected a '%s', got a '%s'"):format(G,E,type(H)),K or 2)end;if I and not I(H)then error(("argument %d: '%s' %s"):format(G,H,J),K or 2)end;return H end;function k.function_arg(L,r,J)k.assert_arg(1,L,'number')local E=type(r)if E=='function'then return r end;if E=='string'then if not i then i=require'pl.operator'.optable end;local M=i[r]if M then return M end;local M,N=k.string_lambda(r)if not M then error(N..': '..r)end;return M elseif E=='table'or E=='userdata'then local F=getmetatable(r)if not F then error('not a callable object',2)end;local O=j[F]if not O then if not F.__call then error('not a callable object',2)end;return r else return O(r)end end;if not J then J=" must be callable"end;if L>0 then error("argument "..L..": "..J,2)else error(J,2)end end;function k.assert_string(G,H)return k.assert_arg(G,H,'string',nil,nil,3)end;function k.on_error(P)P=tostring(P)if({['default']=1,['quit']=2,['error']=3})[P]then g=P else local N="Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(P).."'"if g=='default'then error(N,2)end;h(N)end end;function k.raise(N)if g=='default'then return nil,N elseif g=='quit'then return k.quit(N)else error(N,2)end end;h=k.raise;function k.readfile(Q,R)local P=R and'b'or''k.assert_string(1,Q)local r,S=io.open(Q,'r'..P)if not r then return h(S)end;local T,U=r:read('*a')r:close()if not T then return h(Q..": "..U)end;return T end;function k.writefile(Q,V,R)local P=R and'b'or''k.assert_string(1,Q)k.assert_string(2,V)local r,N=io.open(Q,'w'..P)if not r then return h(N)end;local W,X=r:write(V)r:close()if not W then return h(Q..": "..X)end;return true end;function k.readlines(Q)k.assert_string(1,Q)local r,N=io.open(Q,'r')if not r then return h(N)end;local T={}for Y in r:lines()do d(T,Y)end;r:close()return T end;function k.executeex(Z,_)local a0=os.tmpname()local a1=os.tmpname()if f and not a0:find(':')then a0=os.getenv('TEMP')..a0;a1=os.getenv('TEMP')..a1 end;Z=Z.." > "..k.quote_arg(a0).." 2> "..k.quote_arg(a1)local a2,a3=k.execute(Z)local a4=k.readfile(a0,_)local a5=k.readfile(a1,_)os.remove(a0)os.remove(a1)return a2,a3,a4 or"",a5 or""end;function k.quote_arg(a6)if type(a6)=="table"then local a7={}for o,a8 in ipairs(a6)do a7[o]=k.quote_arg(a8)end;return table.concat(a7," ")end;if f then if a6==""or a6:find('[ \f\t\v]')then a6='"'..a6:gsub([[(\*)"]],[[%1%1\"]]):gsub([[\+$]],"%0%0")..'"'end;return a6:gsub('["^<>!|&%%]',"^%0")else if a6==""or a6:find('[^a-zA-Z0-9_@%+=:,./-]')then a6="'"..a6:gsub("'",[['\'']]).."'"end;return a6 end end;function k.quit(a9,J,...)if type(a9)=='string'then k.fprintf(io.stderr,a9,J,...)io.stderr:write('\n')a9=-1 elseif J then k.fprintf(io.stderr,J,...)io.stderr:write('\n')end;os.exit(a9,true)end;function k.escape(aa)k.assert_string(1,aa)return aa:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1')end;function k.split(aa,ab,ac,G)k.assert_string(1,aa)local ad,ae,d=string.find,string.sub,table.insert;local af,ag=1,{}if not ab then ab='%s+'end;if ab==''then return{aa}end;while true do local ah,ai=ad(aa,ab,af,ac)if not ah then local aj=ae(aa,af)if aj~=''then d(ag,aj)end;if#ag==1 and ag[1]==''then return{}else return ag end end;d(ag,ae(aa,af,ah-1))if G and#ag==G then ag[#ag]=ae(aa,af)return ag end;af=ai+1 end end;function k.splitv(aa,ab,ac,G)return e(k.split(aa,ab,ac,G))end;function k.memoize(ak)local al={}return function(l)local T=al[l]if T==nil then T=ak(l)al[l]=T end;return T end end;function k.add_function_factory(F,am)j[F]=am end;local function an(r)if r:find'^|'or r:find'_'then local ao,ap=r:match'|([^|]*)|(.+)'if r:find'_'then ao='_'ap=r else if not ao then return h'bad string lambda'end end;local aq='return function('..ao..') return '..ap..' end'local M,N=k.load(aq)if not M then return h(N)end;M=M()return M else return h'not a string lambda'end end;k.string_lambda=k.memoize(an)function k.bind1(M,ar)M=k.function_arg(1,M)return function(...)return M(ar,...)end end;function k.bind2(M,ar)M=k.function_arg(1,M)return function(as,...)return M(as,ar,...)end end;do local at=function(J,au)if au then warn(J,"\n",au)else warn(J)end end;function k.set_deprecation_func(ak)if ak==nil then at=function()end else k.assert_arg(1,ak,"function")at=ak end end;function k.raise_deprecation(av)k.assert_arg(1,av,"table")if type(av.message)~="string"then error("field 'message' of the options table must be a string",2)end;local au;if not av.no_trace then au=debug.traceback("",2):match("[\n%s]*(.-)$")end;local J;if av.deprecated_after and av.version_removed then J=(" (deprecated after %s, scheduled for removal in %s)"):format(tostring(av.deprecated_after),tostring(av.version_removed))elseif av.deprecated_after then J=(" (deprecated after %s)"):format(tostring(av.deprecated_after))elseif av.version_removed then J=(" (scheduled for removal in %s)"):format(tostring(av.version_removed))else J=""end;J=av.message..J;if av.source then J="["..av.source.."] "..J else if J:sub(1,1)=="@"then error("message cannot start with '@'",2)end end;at(J,au)end end;return k
